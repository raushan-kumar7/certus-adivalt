import { CertusAdiValtConfig, Environment, LogLevel } from '@/types';
import { CertusAdiValtError } from '@/certus';

/**
 * Singleton configuration manager for the CertusAdiValt system.
 *
 * Responsible for loading, validating, and providing access to the
 * application configuration with environment-specific defaults.
 * Implements the singleton pattern to ensure consistent configuration
 * access across the entire application.
 *
 * @example
 * ```typescript
 * // Initialize with default configuration
 * ConfigManager.getInstance().initialize();
 *
 * // Initialize with custom configuration
 * ConfigManager.getInstance().initialize({
 *   logger: {
 *     level: LogLevel.DEBUG,
 *     service: 'my-service'
 *   }
 * });
 *
 * // Get configuration
 * const config = ConfigManager.getInstance().getConfig();
 * ```
 */
export class ConfigManager {
  private static instance: ConfigManager;
  private config: CertusAdiValtConfig;
  private isInitialized = false;

  /**
   * Private constructor to enforce singleton pattern.
   * Initializes with default configuration derived from environment variables
   * and sensible defaults for each environment.
   */
  private constructor() {
    // Default configuration
    this.config = this.getDefaultConfig();
  }

  /**
   * Gets the singleton instance of ConfigManager.
   * Creates a new instance if one doesn't exist, otherwise returns
   * the existing instance.
   *
   * @returns {ConfigManager} The singleton ConfigManager instance
   *
   * @example
   * ```typescript
   * const configManager = ConfigManager.getInstance();
   * ```
   */
  static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  /**
   * Creates the default configuration based on environment variables
   * and sensible defaults for each environment type.
   *
   * @returns {CertusAdiValtConfig} Default configuration with environment-appropriate values
   *
   * @remarks
   * - Development: Includes stack traces, pretty printing, debug logging
   * - Production: No stack traces exposed, warning level logging, JSON formatting
   * - Staging: Info level logging, no sensitive data exposure
   * - Test: Error level logging only, minimal output
   */
  private getDefaultConfig(): CertusAdiValtConfig {
    const environment = this.getEnvironment();

    return {
      errors: {
        includeStack: environment === 'development',
        logErrors: true,
        exposeDetails: environment === 'development',
        formatError: undefined,
      },
      logger: {
        level: this.getLogLevel(environment),
        service: process.env.SERVICE_NAME || 'certus-adivalt-app',
        environment: environment,
        redactFields: ['password', 'token', 'secret', 'authorization', 'apiKey', 'creditCard'],
        prettyPrint: environment === 'development',
        timestampFormat: 'ISO',
        version: process.env.APP_VERSION || '1.0.0',
      },
      responses: {
        includeTimestamp: true,
        includeRequestId: true,
        successMessage: undefined,
        pagination: {
          defaultPage: 1,
          defaultLimit: 20,
          maxLimit: 100,
        },
      },
      middleware: {
        enableErrorHandler: true,
        enableLogging: true,
        enableSecurity: true,
        skipPaths: ['/health', '/metrics', '/favicon.ico'],
      },
    };
  }

  /**
   * Determines the current environment from NODE_ENV environment variable.
   * Falls back to 'development' if NODE_ENV is not set or unrecognized.
   *
   * @returns {Environment} Current environment type
   *
   * @remarks
   * Maps common NODE_ENV values to internal Environment types:
   * - 'production' → 'production'
   * - 'staging' → 'stagging' (note the spelling difference)
   * - 'test' → 'test'
   * - Everything else → 'development'
   */
  private getEnvironment(): Environment {
    const env = process.env.NODE_ENV || 'development';

    switch (env) {
      case 'production':
        return 'production';
      case 'staging':
        return 'stagging';
      case 'test':
        return 'test';
      default:
        return 'development';
    }
  }

  /**
   * Maps environment to appropriate log level based on operational requirements.
   *
   * @param {Environment} environment - Current application environment
   * @returns {LogLevel} Log level appropriate for the given environment
   *
   * @remarks
   * Environment to log level mapping:
   * - development: DEBUG (maximum visibility)
   * - stagging: INFO (balanced visibility)
   * - production: WARN (errors and warnings only)
   * - test: ERROR (errors only)
   */
  private getLogLevel(environment: Environment): LogLevel {
    const levelMap: Record<Environment, LogLevel> = {
      development: LogLevel.DEBUG,
      stagging: LogLevel.INFO,
      production: LogLevel.WARN,
      test: LogLevel.ERROR,
    };

    return levelMap[environment] || LogLevel.INFO;
  }

  /**
   * Initializes the configuration manager with optional user overrides.
   * Merges user configuration with defaults and validates the result.
   *
   * @param {Partial<CertusAdiValtConfig>} [userConfig] - Partial configuration object
   *        containing user-specific overrides. All properties are optional and will
   *        be deep-merged with default configuration.
   *
   * @throws {CertusAdiValtError} CFG_ALREADY_INITIALIZED - When configuration has
   *         already been initialized and this method is called again
   * @throws {CertusAdiValtError} CFG_INVALID_LOG_LEVEL - When log level is outside valid range
   * @throws {CertusAdiValtError} CFG_INVALID_SERVICE_NAME - When service name is missing or invalid
   * @throws {CertusAdiValtError} CFG_INVALID_PAGINATION - When pagination settings are invalid
   * @throws {CertusAdiValtError} CFG_INVALID_SKIP_PATHS - When middleware skip paths is not an array
   *
   * @example
   * ```typescript
   * // Initialize with custom logging and response settings
   * configManager.initialize({
   *   logger: {
   *     level: LogLevel.DEBUG,
   *     service: 'my-app',
   *     redactFields: ['password', 'token', 'customSecret']
   *   },
   *   responses: {
   *     includeRequestId: false,
   *     pagination: {
   *       defaultLimit: 50,
   *       maxLimit: 200
   *     }
   *   }
   * });
   * ```
   */
  initialize(userConfig?: Partial<CertusAdiValtConfig>): void {
    if (this.isInitialized) {
      throw new CertusAdiValtError(
        'Configuration already initialized',
        'CFG_ALREADY_INITIALIZED',
        400
      );
    }

    // Merge user configuration with defaults
    this.config = this.deepMerge(this.config, userConfig || {});

    // Validate configuration
    this.validateConfig();

    this.isInitialized = true;
  }

  /**
   * Deep merges two objects, recursively combining nested objects while
   * handling arrays and primitive values appropriately.
   *
   * @param {any} target - Target object to merge into. This object will be
   *        used as the base for the merge operation.
   * @param {any} source - Source object to merge from. Properties from this
   *        object will take precedence over target properties.
   * @returns {any} New object containing the deeply merged result
   *
   * @remarks
   * - Primitive values and arrays from source overwrite target completely
   * - Nested objects are merged recursively
   * - Does not modify the original target or source objects
   * - Handles null and undefined values appropriately
   */
  private deepMerge(target: any, source: any): any {
    const result = { ...target };

    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this.deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }

    return result;
  }

  /**
   * Validates the current configuration for correctness and consistency.
   * Performs comprehensive checks on all configuration sections.
   *
   * @throws {CertusAdiValtError} CFG_INVALID_LOG_LEVEL - When log level is outside
   *         the valid range (LogLevel.ERROR to LogLevel.TRACE)
   * @throws {CertusAdiValtError} CFG_INVALID_SERVICE_NAME - When service name is
   *         missing, empty, or not a string
   * @throws {CertusAdiValtError} CFG_INVALID_PAGINATION - When pagination settings
   *         are invalid (defaultPage < 1, or defaultLimit outside 1-maxLimit range)
   * @throws {CertusAdiValtError} CFG_INVALID_SKIP_PATHS - When middleware skipPaths
   *         is not an array
   *
   * @remarks
   * This method is called automatically during initialization and configuration updates
   * to ensure configuration integrity throughout the application lifecycle.
   */
  private validateConfig(): void {
    const { logger, responses, middleware } = this.config;

    // Validate logger configuration
    if (logger.level < LogLevel.ERROR || logger.level > LogLevel.TRACE) {
      throw new CertusAdiValtError('Invalid log level', 'CFG_INVALID_LOG_LEVEL', 400, {
        level: logger.level,
      });
    }

    if (!logger.service || typeof logger.service !== 'string') {
      throw new CertusAdiValtError('Service name is required', 'CFG_INVALID_SERVICE_NAME', 400);
    }

    // Validate pagination configuration
    if (responses.pagination.defaultPage < 1) {
      throw new CertusAdiValtError(
        'Default page must be at least 1',
        'CFG_INVALID_PAGINATION',
        400
      );
    }

    if (
      responses.pagination.defaultLimit < 1 ||
      responses.pagination.defaultLimit > responses.pagination.maxLimit
    ) {
      throw new CertusAdiValtError(
        `Default limit must be between 1 and ${responses.pagination.maxLimit}`,
        'CFG_INVALID_PAGINATION',
        400
      );
    }

    // Validate middleware skip paths
    if (!Array.isArray(middleware.skipPaths)) {
      throw new CertusAdiValtError('Skip paths must be an array', 'CFG_INVALID_SKIP_PATHS', 400);
    }
  }

  // Getters for specific configuration sections

  /**
   * Gets the complete configuration object.
   * Returns a deep copy to prevent external modification of internal configuration.
   *
   * @returns {CertusAdiValtConfig} Complete configuration object containing all
   *          settings for errors, logger, responses, and middleware
   *
   * @throws {CertusAdiValtError} CFG_NOT_INITIALIZED - When configuration has not
   *         been initialized via initialize() method
   *
   * @example
   * ```typescript
   * const config = configManager.getConfig();
   * console.log(config.logger.level); // Access logger settings
   * console.log(config.responses.pagination.defaultLimit); // Access pagination settings
   * ```
   */
  getConfig(): CertusAdiValtConfig {
    if (!this.isInitialized) {
      throw new CertusAdiValtError(
        'Configuration not initialized. Call initialize() first.',
        'CFG_NOT_INITIALIZED',
        500
      );
    }
    return { ...this.config };
  }

  /**
   * Gets the errors configuration section.
   *
   * @returns {Object} Errors configuration containing settings for:
   *          - includeStack: boolean - Whether to include stack traces
   *          - logErrors: boolean - Whether to log errors internally
   *          - exposeDetails: boolean - Whether to expose details to clients
   *          - formatError: function - Optional custom error formatter
   */
  getErrorsConfig() {
    return { ...this.config.errors };
  }

  /**
   * Gets the logger configuration section.
   *
   * @returns {Object} Logger configuration containing settings for:
   *          - level: LogLevel - Minimum logging level
   *          - service: string - Service name
   *          - environment: Environment - Runtime environment
   *          - redactFields: string[] - Fields to redact in logs
   *          - prettyPrint: boolean - Whether to use pretty printing
   *          - timestampFormat: string - Timestamp format
   *          - version: string - Application version
   */
  getLoggerConfig() {
    return { ...this.config.logger };
  }

  /**
   * Gets the responses configuration section.
   *
   * @returns {Object} Responses configuration containing settings for:
   *          - includeTimestamp: boolean - Whether to include timestamps
   *          - includeRequestId: boolean - Whether to include request IDs
   *          - successMessage: string - Optional default success message
   *          - pagination: Object - Pagination settings (defaultPage, defaultLimit, maxLimit)
   */
  getResponsesConfig() {
    return { ...this.config.responses };
  }

  /**
   * Gets the middleware configuration section.
   *
   * @returns {Object} Middleware configuration containing settings for:
   *          - enableErrorHandler: boolean - Whether to enable error handler
   *          - enableLogging: boolean - Whether to enable logging
   *          - enableSecurity: boolean - Whether to enable security
   *          - skipPaths: string[] - Paths to skip middleware processing
   */
  getMiddlewareConfig() {
    return { ...this.config.middleware };
  }

  // Environment-specific helpers

  /**
   * Checks if the current environment is development.
   *
   * @returns {boolean} True if environment is 'development', false otherwise
   *
   * @example
   * ```typescript
   * if (configManager.isDevelopment()) {
   *   // Enable development-only features
   *   app.use('/dev-tools', devToolsMiddleware);
   * }
   * ```
   */
  isDevelopment(): boolean {
    return this.config.logger.environment === 'development';
  }

  /**
   * Checks if the current environment is production.
   *
   * @returns {boolean} True if environment is 'production', false otherwise
   *
   * @example
   * ```typescript
   * if (configManager.isProduction()) {
   *   // Enable production optimizations
   *   app.enable('view cache');
   * }
   * ```
   */
  isProduction(): boolean {
    return this.config.logger.environment === 'production';
  }

  /**
   * Checks if the current environment is staging.
   *
   * @returns {boolean} True if environment is 'stagging', false otherwise
   *
   * @remarks
   * Note: Uses 'stagging' spelling (with double 'g') to match the Environment type
   */
  isStaging(): boolean {
    return this.config.logger.environment === 'stagging';
  }

  /**
   * Checks if the current environment is test.
   *
   * @returns {boolean} True if environment is 'test', false otherwise
   *
   * @example
   * ```typescript
   * if (configManager.isTest()) {
   *   // Use test database
   *   db.connect(process.env.TEST_DATABASE_URL);
   * }
   * ```
   */
  isTest(): boolean {
    return this.config.logger.environment === 'test';
  }

  // Dynamic configuration updates

  /**
   * Updates the configuration with partial changes.
   * Performs deep merge with existing configuration and revalidates.
   *
   * @param {Partial<CertusAdiValtConfig>} updates - Partial configuration object
   *        containing the settings to update. Only specified properties will be changed.
   *
   * @throws {CertusAdiValtError} CFG_NOT_INITIALIZED - When configuration has not
   *         been initialized via initialize() method
   * @throws {CertusAdiValtError} Various validation errors - When updated configuration
   *         fails validation (same errors as initialize method)
   *
   * @example
   * ```typescript
   * // Update log level dynamically
   * configManager.updateConfig({
   *   logger: {
   *     level: LogLevel.ERROR
   *   }
   * });
   *
   * // Update multiple sections
   * configManager.updateConfig({
   *   logger: {
   *     level: LogLevel.INFO
   *   },
   *   middleware: {
   *     skipPaths: ['/health', '/metrics', '/debug']
   *   }
   * });
   * ```
   */
  updateConfig(updates: Partial<CertusAdiValtConfig>): void {
    if (!this.isInitialized) {
      throw new CertusAdiValtError('Configuration not initialized', 'CFG_NOT_INITIALIZED', 500);
    }

    this.config = this.deepMerge(this.config, updates);
    this.validateConfig();
  }

  // Environment variable helpers

  /**
   * Gets a required environment variable.
   *
   * @param {string} key - Environment variable name to retrieve
   * @param {string} [defaultValue] - Optional default value to return if environment
   *        variable is not set. If not provided and variable is missing, throws an error.
   * @returns {string} Environment variable value
   *
   * @throws {CertusAdiValtError} CFG_MISSING_ENV_VAR - When environment variable is
   *         not set and no default value is provided
   *
   * @example
   * ```typescript
   * const dbUrl = configManager.getEnvVar('DATABASE_URL'); // Throws if not set
   * const port = configManager.getEnvVar('PORT', '3000'); // Uses default if not set
   * ```
   */
  getEnvVar(key: string, defaultValue?: string): string {
    const value = process.env[key];

    if (value === undefined) {
      if (defaultValue !== undefined) {
        return defaultValue;
      }
      throw new CertusAdiValtError(
        `Required environment variable ${key} is not set`,
        'CFG_MISSING_ENV_VAR',
        500
      );
    }

    return value;
  }

  /**
   * Gets an optional environment variable.
   *
   * @param {string} key - Environment variable name to retrieve
   * @param {string} [defaultValue] - Optional default value to return if environment
   *        variable is not set
   * @returns {string | undefined} Environment variable value, default value, or undefined
   *
   * @example
   * ```typescript
   * const apiKey = configManager.getEnvVarOptional('API_KEY'); // undefined if not set
   * const timeout = configManager.getEnvVarOptional('TIMEOUT', '5000'); // '5000' if not set
   * ```
   */
  getEnvVarOptional(key: string, defaultValue?: string): string | undefined {
    return process.env[key] || defaultValue;
  }

  /**
   * Gets a required numeric environment variable.
   * Parses the environment variable value as a number and validates it.
   *
   * @param {string} key - Environment variable name to retrieve
   * @param {number} [defaultValue] - Optional default number to return if environment
   *        variable is not set. If not provided and variable is missing, throws an error.
   * @returns {number} Parsed numeric value
   *
   * @throws {CertusAdiValtError} CFG_MISSING_ENV_VAR - When environment variable is
   *         not set and no default value is provided
   * @throws {CertusAdiValtError} CFG_INVALID_ENV_VAR - When environment variable value
   *         cannot be parsed as a valid number
   *
   * @example
   * ```typescript
   * const port = configManager.getEnvVarNumber('PORT', 3000);
   * const workers = configManager.getEnvVarNumber('WORKER_COUNT'); // Throws if not set
   * const maxConnections = configManager.getEnvVarNumber('MAX_CONNECTIONS', 100);
   * ```
   */
  getEnvVarNumber(key: string, defaultValue?: number): number {
    const value = process.env[key];

    if (value === undefined) {
      if (defaultValue !== undefined) {
        return defaultValue;
      }
      throw new CertusAdiValtError(
        `Required environment variable ${key} is not set`,
        'CFG_MISSING_ENV_VAR',
        500
      );
    }

    const numValue = Number(value);
    if (isNaN(numValue)) {
      throw new CertusAdiValtError(
        `Environment variable ${key} must be a number`,
        'CFG_INVALID_ENV_VAR',
        500,
        { value }
      );
    }

    return numValue;
  }

  /**
   * Gets a required boolean environment variable.
   * Parses the environment variable value as a boolean and validates it.
   *
   * @param {string} key - Environment variable name to retrieve
   * @param {boolean} [defaultValue] - Optional default boolean to return if environment
   *        variable is not set. If not provided and variable is missing, throws an error.
   * @returns {boolean} Parsed boolean value
   *
   * @throws {CertusAdiValtError} CFG_MISSING_ENV_VAR - When environment variable is
   *         not set and no default value is provided
   * @throws {CertusAdiValtError} CFG_INVALID_ENV_VAR - When environment variable value
   *         cannot be parsed as a valid boolean
   *
   * @remarks
   * Accepts the following case-insensitive values as true:
   * - 'true', '1', 'yes'
   * Accepts the following case-insensitive values as false:
   * - 'false', '0', 'no'
   *
   * @example
   * ```typescript
   * const debug = configManager.getEnvVarBoolean('DEBUG', false);
   * const ssl = configManager.getEnvVarBoolean('SSL_ENABLED', true);
   * const maintenance = configManager.getEnvVarBoolean('MAINTENANCE_MODE'); // Throws if not set
   * ```
   */
  getEnvVarBoolean(key: string, defaultValue?: boolean): boolean {
    const value = process.env[key];

    if (value === undefined) {
      if (defaultValue !== undefined) {
        return defaultValue;
      }
      throw new CertusAdiValtError(
        `Required environment variable ${key} is not set`,
        'CFG_MISSING_ENV_VAR',
        500
      );
    }

    const normalizedValue = value.toLowerCase();
    if (normalizedValue === 'true' || normalizedValue === '1' || normalizedValue === 'yes') {
      return true;
    }
    if (normalizedValue === 'false' || normalizedValue === '0' || normalizedValue === 'no') {
      return false;
    }

    throw new CertusAdiValtError(
      `Environment variable ${key} must be a boolean`,
      'CFG_INVALID_ENV_VAR',
      500,
      { value }
    );
  }

  /**
   * Resets the configuration to defaults and marks as uninitialized.
   * Primarily intended for testing scenarios where clean state is required.
   *
   * @example
   * ```typescript
   * // In test setup
   * beforeEach(() => {
   *   configManager.reset();
   * });
   *
   * // Or for specific test cases
   * it('should work with default config', () => {
   *   configManager.reset();
   *   // Test with default configuration
   * });
   * ```
   */
  reset(): void {
    this.config = this.getDefaultConfig();
    this.isInitialized = false;
  }
}


import { CertusAdiValtError } from '@/certus';

/**
 * A collection of common utility functions used throughout the CertusAdiValt system.
 * Provides helper methods for cloning, validation, string manipulation, and async operations.
 *
 * All methods are static and can be used without instantiating the class.
 *
 * @example
 * ```typescript
 * // Deep clone an object
 * const cloned = CommonUtils.deepClone(originalObject);
 *
 * // Generate random string
 * const randomId = CommonUtils.generateRandomString(32);
 *
 * // Retry with exponential backoff
 * const result = await CommonUtils.retry(() => fetchData(), { maxAttempts: 3 });
 * ```
 */
export class CommonUtils {
  /**
   * Deep clone an object, handling dates, arrays, and nested objects.
   * Creates a completely new copy with no references to the original.
   *
   * @template T - The type of the object being cloned
   * @param {T} obj - The object to deep clone. Can be any type including primitives, arrays, dates, and objects.
   * @returns {T} A deep clone of the original object
   *
   * @remarks
   * - Primitive values are returned directly
   * - Date objects are cloned with same timestamp
   * - Arrays are recursively cloned
   * - Objects are recursively cloned (own properties only)
   * - Circular references are not handled and will cause stack overflow
   *
   * @example
   * ```typescript
   * const original = { a: 1, b: { c: 2 }, d: new Date() };
   * const cloned = CommonUtils.deepClone(original);
   * console.log(cloned === original); // false
   * console.log(cloned.b === original.b); // false
   * ```
   */
  static deepClone<T>(obj: T): T {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    if (obj instanceof Date) {
      return new Date(obj.getTime()) as unknown as T;
    }

    if (obj instanceof Array) {
      return obj.map((item) => this.deepClone(item)) as unknown as T;
    }

    if (typeof obj === 'object') {
      const cloned = {} as T;
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          cloned[key] = this.deepClone(obj[key]);
        }
      }
      return cloned;
    }

    return obj;
  }

  /**
   * Check if a value is empty. Handles null, undefined, empty strings, arrays, and objects.
   *
   * @param {any} value - The value to check for emptiness
   * @returns {boolean} True if the value is considered empty, false otherwise
   *
   * @remarks
   * Considered empty values:
   * - null or undefined
   * - Empty string ('')
   * - Empty array ([])
   * - Empty object ({})
   * - All other values (numbers, booleans, non-empty strings/arrays/objects) return false
   *
   * @example
   * ```typescript
   * CommonUtils.isEmpty(null); // true
   * CommonUtils.isEmpty(''); // true
   * CommonUtils.isEmpty([]); // true
   * CommonUtils.isEmpty({}); // true
   * CommonUtils.isEmpty('hello'); // false
   * CommonUtils.isEmpty([1, 2]); // false
   * CommonUtils.isEmpty(0); // false
   * CommonUtils.isEmpty(false); // false
   * ```
   */
  static isEmpty(value: any): boolean {
    if (value === null || value === undefined) {
      return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
      return value.length === 0;
    }

    if (typeof value === 'object') {
      return Object.keys(value).length === 0;
    }

    return false;
  }

  /**
   * Generate a cryptographically insecure random string of specified length.
   * Uses alphanumeric characters (A-Z, a-z, 0-9).
   *
   * @param {number} [length=16] - The length of the random string to generate. Defaults to 16.
   * @returns {string} Random string of specified length
   *
   * @throws {Error} If length is not a positive integer
   *
   * @remarks
   * - Not suitable for cryptographic purposes (uses Math.random())
   * - For security-sensitive random strings, use crypto.randomBytes() in Node.js
   * - Character set: 62 characters (26 uppercase + 26 lowercase + 10 digits)
   *
   * @example
   * ```typescript
   * const random = CommonUtils.generateRandomString(32);
   * console.log(random); // "aB3x9pQ2rT8yZ1mN7vW4cK6lP0oJ5hG"
   * ```
   */
  static generateRandomString(length: number = 16): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';

    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }

    return result;
  }

  /**
   * Sleep for specified milliseconds. Returns a promise that resolves after the delay.
   *
   * @param {number} ms - Number of milliseconds to sleep
   * @returns {Promise<void>} Promise that resolves after specified milliseconds
   *
   * @example
   * ```typescript
   * // Sleep for 1 second
   * await CommonUtils.sleep(1000);
   * console.log('1 second later');
   *
   * // Use in async functions
   * async function delayedOperation() {
   *   await CommonUtils.sleep(500);
   *   return performOperation();
   * }
   * ```
   */
  static sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Retry an async function with exponential backoff and configurable retry logic.
   *
   * @template T - The return type of the async function
   * @param {() => Promise<T>} fn - Async function to retry. Should return a Promise.
   * @param {Object} [options] - Retry configuration options
   * @param {number} [options.maxAttempts=3] - Maximum number of retry attempts (including initial)
   * @param {number} [options.delayMs=1000] - Initial delay between attempts in milliseconds
   * @param {number} [options.backoffMultiplier=2] - Multiplier for delay after each attempt
   * @param {(error: Error) => boolean} [options.shouldRetry=() => true] - Function to determine if error should be retried
   * @returns {Promise<T>} Promise resolving with the result of the successful function call
   *
   * @throws {CertusAdiValtError} UTL_RETRY_EXHAUSTED - When all retry attempts are exhausted
   * @throws {Error} The original error if shouldRetry returns false
   *
   * @remarks
   * - Delay pattern: delayMs, delayMs * backoffMultiplier, delayMs * backoffMultiplier^2, etc.
   * - The shouldRetry function receives the caught error and should return true to retry
   * - If shouldRetry returns false, the original error is thrown immediately
   *
   * @example
   * ```typescript
   * // Basic retry
   * const result = await CommonUtils.retry(() => fetch('https://api.example.com/data'));
   *
   * // Custom retry logic
   * const result = await CommonUtils.retry(
   *   () => apiCall(),
   *   {
   *     maxAttempts: 5,
   *     delayMs: 500,
   *     backoffMultiplier: 1.5,
   *     shouldRetry: (error) => error.statusCode >= 500
   *   }
   * );
   * ```
   */
  static async retry<T>(
    fn: () => Promise<T>,
    options: {
      maxAttempts?: number;
      delayMs?: number;
      backoffMultiplier?: number;
      shouldRetry?: (error: Error) => boolean;
    } = {}
  ): Promise<T> {
    const {
      maxAttempts = 3,
      delayMs = 1000,
      backoffMultiplier = 2,
      shouldRetry = () => true,
    } = options;

    let lastError: Error;
    let currentDelay = delayMs;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;

        if (!shouldRetry(lastError) || attempt === maxAttempts) {
          throw new CertusAdiValtError(
            `Operation failed after ${attempt} attempts`,
            'UTL_RETRY_EXHAUSTED',
            500,
            { originalError: lastError, attempts: attempt }
          );
        }

        if (attempt < maxAttempts) {
          await this.sleep(currentDelay);
          currentDelay *= backoffMultiplier;
        }
      }
    }

    throw lastError!;
  }

  /**
   * Debounce function execution. Delays function execution until after wait milliseconds
   * have elapsed since the last time the debounced function was invoked.
   *
   * @template T - The function type to debounce
   * @param {T} func - The function to debounce
   * @param {number} wait - Number of milliseconds to delay
   * @param {boolean} [immediate=false] - If true, trigger function on leading edge instead of trailing
   * @returns {(...args: Parameters<T>) => void} Debounced function
   *
   * @example
   * ```typescript
   * // Debounce search input
   * const debouncedSearch = CommonUtils.debounce((query: string) => {
   *   performSearch(query);
   * }, 300);
   *
   * // Use in event handler
   * input.addEventListener('input', (e) => {
   *   debouncedSearch(e.target.value);
   * });
   *
   * // Immediate execution (leading edge)
   * const immediateDebounce = CommonUtils.debounce(() => {
   *   console.log('Executed immediately on first call');
   * }, 300, true);
   * ```
   */
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number,
    immediate: boolean = false
  ): (...args: Parameters<T>) => void {
    let timeout: NodeJS.Timeout | null = null;

    return (...args: Parameters<T>) => {
      const later = () => {
        timeout = null;
        if (!immediate) func(...args);
      };

      const callNow = immediate && !timeout;

      if (timeout) {
        clearTimeout(timeout);
      }

      timeout = setTimeout(later, wait);

      if (callNow) {
        func(...args);
      }
    };
  }

  /**
   * Throttle function execution. Ensures function is only called at most once per specified limit.
   *
   * @template T - The function type to throttle
   * @param {T} func - The function to throttle
   * @param {number} limit - Number of milliseconds between allowed executions
   * @returns {(...args: Parameters<T>) => void} Throttled function
   *
   * @example
   * ```typescript
   * // Throttle scroll events
   * const throttledScroll = CommonUtils.throttle(() => {
   *   updateScrollPosition();
   * }, 100);
   *
   * window.addEventListener('scroll', throttledScroll);
   *
   * // Throttle resize events
   * const throttledResize = CommonUtils.throttle(() => {
   *   handleResize();
   * }, 250);
   * ```
   */
  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean = false;

    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => {
          inThrottle = false;
        }, limit);
      }
    };
  }

  /**
   * Parse JSON safely with default value fallback.
   *
   * @template T - The expected type after parsing
   * @param {string} jsonString - JSON string to parse
   * @param {T} [defaultValue] - Default value to return if parsing fails
   * @returns {T | undefined} Parsed JSON object or defaultValue if parsing fails
   *
   * @example
   * ```typescript
   * // Basic usage
   * const obj = CommonUtils.safeJsonParse('{"a": 1}'); // { a: 1 }
   *
   * // With default value
   * const obj = CommonUtils.safeJsonParse('invalid json', { fallback: true }); // { fallback: true }
   *
   * // Without default (returns undefined)
   * const obj = CommonUtils.safeJsonParse('invalid json'); // undefined
   * ```
   */
  static safeJsonParse<T>(jsonString: string, defaultValue?: T): T | undefined {
    try {
      return JSON.parse(jsonString);
    } catch {
      return defaultValue;
    }
  }

  /**
   * Stringify JSON safely with error handling and default value fallback.
   *
   * @param {any} obj - Object to stringify
   * @param {string} [defaultValue='{}'] - Default JSON string to return if stringification fails
   * @returns {string} JSON string representation of the object
   *
   * @example
   * ```typescript
   * // Basic usage
   * const json = CommonUtils.safeJsonStringify({ a: 1 }); // '{"a":1}'
   *
   * // With circular reference (fails safely)
   * const circular = { a: 1 };
   * circular.self = circular;
   * const json = CommonUtils.safeJsonStringify(circular, '{"error": "circular"}'); // '{"error": "circular"}'
   * ```
   */
  static safeJsonStringify(obj: any, defaultValue: string = '{}'): string {
    try {
      return JSON.stringify(obj);
    } catch {
      return defaultValue;
    }
  }

  /**
   * Validate email format using basic regex pattern.
   *
   * @param {string} email - Email address to validate
   * @returns {boolean} True if email format is valid, false otherwise
   *
   * @remarks
   * Uses basic validation pattern: local-part@domain.tld
   * - Local part: one or more non-whitespace, non-@ characters
   * - Domain: one or more non-whitespace, non-@ characters
   * - TLD: one or more non-whitespace, non-@ characters
   * - Does not validate domain existence or special cases
   *
   * @example
   * ```typescript
   * CommonUtils.isValidEmail('user@example.com'); // true
   * CommonUtils.isValidEmail('invalid-email'); // false
   * CommonUtils.isValidEmail('user@domain'); // false
   * ```
   */
  static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Validate URL format using the URL constructor.
   *
   * @param {string} url - URL string to validate
   * @returns {boolean} True if URL format is valid, false otherwise
   *
   * @remarks
   * - Uses the native URL constructor for validation
   * - Returns false for malformed URLs
   * - Accepts both http/https and other protocols
   * - Requires protocol and valid domain format
   *
   * @example
   * ```typescript
   * CommonUtils.isValidUrl('https://example.com'); // true
   * CommonUtils.isValidUrl('ftp://files.example.com'); // true
   * CommonUtils.isValidUrl('not-a-url'); // false
   * CommonUtils.isValidUrl('example.com'); // false (missing protocol)
   * ```
   */
  static isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Format bytes to human readable string with appropriate unit.
   *
   * @param {number} bytes - Number of bytes to format
   * @param {number} [decimals=2] - Number of decimal places to include
   * @returns {string} Formatted string with appropriate unit (Bytes, KB, MB, etc.)
   *
   * @throws {Error} If bytes is negative
   *
   * @remarks
   * Uses binary (1024-based) units:
   * - KB: 1024 bytes
   * - MB: 1024^2 bytes
   * - GB: 1024^3 bytes
   * - etc.
   *
   * @example
   * ```typescript
   * CommonUtils.formatBytes(0); // "0 Bytes"
   * CommonUtils.formatBytes(1024); // "1 KB"
   * CommonUtils.formatBytes(1048576); // "1 MB"
   * CommonUtils.formatBytes(1234567); // "1.18 MB"
   * CommonUtils.formatBytes(1234567, 0); // "1 MB"
   * ```
   */
  static formatBytes(bytes: number, decimals: number = 2): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

  /**
   * Generate a unique ID combining timestamp and random characters.
   * Not cryptographically secure but suitable for most unique identifier needs.
   *
   * @param {string} [prefix=''] - Optional prefix for the generated ID
   * @returns {string} Unique ID string
   *
   * @remarks
   * Format: [prefix] + timestamp(base36) + random(base36)
   * - Timestamp: Current time in base36 for compactness
   * - Random: 6 characters of random base36 string
   * - Collision probability is very low for most use cases
   *
   * @example
   * ```typescript
   * CommonUtils.generateId(); // "kf91pzabc123"
   * CommonUtils.generateId('user_'); // "user_kf91pzabc123"
   * CommonUtils.generateId('order-'); // "order-kf91pzabc123"
   * ```
   */
  static generateId(prefix: string = ''): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    return `${prefix}${timestamp}${random}`;
  }

  /**
   * Mask sensitive data in strings, showing only specified number of characters at ends.
   *
   * @param {string} str - String containing sensitive data to mask
   * @param {number} [visibleChars=4] - Number of characters to keep visible at start and end
   * @returns {string} Masked string with middle characters replaced by asterisks
   *
   * @example
   * ```typescript
   * CommonUtils.maskSensitiveData('1234567890123456'); // "1234************3456"
   * CommonUtils.maskSensitiveData('secret-token', 2); // "se********en"
   * CommonUtils.maskSensitiveData('short', 2); // "*****" (too short to partially show)
   * ```
   */
  static maskSensitiveData(str: string, visibleChars: number = 4): string {
    if (str.length <= visibleChars * 2) {
      return '*'.repeat(str.length);
    }

    const firstVisible = str.substring(0, visibleChars);
    const lastVisible = str.substring(str.length - visibleChars);
    const maskedLength = str.length - visibleChars * 2;

    return `${firstVisible}${'*'.repeat(maskedLength)}${lastVisible}`;
  }

  /**
   * Check if code is running in a Node.js environment.
   *
   * @returns {boolean} True if running in Node.js, false otherwise
   *
   * @example
   * ```typescript
   * if (CommonUtils.isNodeEnvironment()) {
   *   // Use Node.js specific APIs
   *   const fs = require('fs');
   * }
   * ```
   */
  static isNodeEnvironment(): boolean {
    return (
      typeof process !== 'undefined' && process.versions != null && process.versions.node != null
    );
  }

  /**
   * Check if code is running in a browser environment.
   *
   * @returns {boolean} True if running in browser, false otherwise
   *
   * @example
   * ```typescript
   * if (CommonUtils.isBrowserEnvironment()) {
   *   // Use browser specific APIs
   *   window.localStorage.setItem('key', 'value');
   * }
   * ```
   */
  static isBrowserEnvironment(): boolean {
    return (
      typeof globalThis !== 'undefined' &&
      typeof (globalThis as any).window !== 'undefined' &&
      typeof (globalThis as any).document !== 'undefined'
    );
  }
}

import { ErrorCodes, HttpStatus } from '@/constants';
import { ErrorContext } from '@/types';

/**
 * Custom error class for the CertusAdiValt system with enhanced error handling capabilities.
 *
 * Extends the native Error class to include structured error information, HTTP status codes,
 * contextual metadata, and chainable builder methods for error customization.
 *
 * @example
 * ```typescript
 * // Basic error creation
 * throw new CertusAdiValtError('User not found', 'USER_NOT_FOUND', 404);
 *
 * // Error with context and original error
 * try {
 *   await someOperation();
 * } catch (error) {
 *   throw new CertusAdiValtError(
 *     'Operation failed',
 *     'OP_FAILED',
 *     500,
 *     { userId: 123, operation: 'update' },
 *     error
 *   );
 * }
 *
 * // Using builder pattern
 * throw new CertusAdiValtError('Initial error')
 *   .withCode('VALIDATION_ERROR')
 *   .withStatusCode(400)
 *   .withContext({ field: 'email', value: 'invalid' });
 * ```
 */
export class CertusAdiValtError extends Error {
  /**
   * Machine-readable error code for programmatic error handling.
   * @type {string}
   */
  public readonly code: string;

  /**
   * HTTP status code associated with the error.
   * @type {number}
   */
  public readonly statusCode: number;

  /**
   * Timestamp when the error was created.
   * @type {Date}
   */
  public readonly timestamp: Date;

  /**
   * Additional contextual information about the error.
   * @type {Record<string, unknown>}
   */
  public readonly context: Record<string, unknown>;

  /**
   * Original error that caused this error, if any.
   * @type {Error | undefined}
   */
  public readonly originalError?: Error;

  /**
   * Creates a new CertusAdiValtError instance.
   *
   * @param {string} message - Human-readable error description
   * @param {string} [code=ErrorCodes.SRV_INTERNAL_ERROR] - Machine-readable error code
   * @param {number} [statusCode=HttpStatus.INTERNAL_SERVER_ERROR] - HTTP status code
   * @param {Record<string, unknown>} [context={}] - Additional error context
   * @param {Error} [originalError] - Original error that caused this error
   *
   * @example
   * ```typescript
   * // Minimal error
   * new CertusAdiValtError('Something went wrong');
   *
   * // Full error with all parameters
   * new CertusAdiValtError(
   *   'Database connection failed',
   *   'DB_CONNECTION_ERROR',
   *   503,
   *   { host: 'localhost', port: 5432 },
   *   originalError
   * );
   * ```
   */
  constructor(
    message: string,
    code: string = ErrorCodes.SRV_INTERNAL_ERROR,
    statusCode: number = HttpStatus.INTERNAL_SERVER_ERROR,
    context: Record<string, unknown> = {},
    originalError?: Error
  ) {
    super(message);
    this.name = 'CertusAdiValtError';
    this.code = code;
    this.statusCode = statusCode;
    this.timestamp = new Date();
    this.context = context;
    this.originalError = originalError;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CertusAdiValtError);
    }

    Object.setPrototypeOf(this, CertusAdiValtError.prototype);
  }

  /**
   * Converts the error to a structured JSON representation suitable for API responses.
   *
   * @returns {ErrorContext} Structured error context object with all error details
   *
   * @remarks
   * The returned object includes:
   * - Error name, message, code, and status code
   * - Timestamp of error creation
   * - Additional context metadata
   * - Stack trace (if available)
   * - Original error details (name, message, stack) if present
   *
   * @example
   * ```typescript
   * const error = new CertusAdiValtError('Not found', 'NOT_FOUND', 404);
   * const json = error.toJSON();
   * // Returns:
   * // {
   * //   name: 'CertusAdiValtError',
   * //   message: 'Not found',
   * //   code: 'NOT_FOUND',
   * //   statusCode: 404,
   * //   timestamp: Date,
   * //   context: {},
   * //   stack: '...',
   * //   originalError: undefined
   * // }
   * ```
   */
  public toJSON(): ErrorContext {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      statusCode: this.statusCode,
      timestamp: this.timestamp,
      context: this.context,
      stack: this.stack,
      originalError: this.originalError
        ? {
            name: this.originalError.name,
            message: this.originalError.message,
            stack: this.originalError.stack,
          }
        : undefined,
    };
  }

  /**
   * Converts the error to a log-friendly format with reduced verbosity.
   *
   * @returns {Record<string, unknown>} Simplified error representation for logging
   *
   * @remarks
   * Compared to toJSON(), this method:
   * - Uses ISO string for timestamp instead of Date object
   * - Provides simplified original error (name and message only)
   * - Structures output for better log aggregation and parsing
   * - Excludes full stack traces from original errors
   *
   * @example
   * ```typescript
   * const error = new CertusAdiValtError('DB error', 'DB_ERROR', 500);
   * const logData = error.toLog();
   * console.error('Operation failed:', logData);
   * ```
   */
  public toLog(): Record<string, unknown> {
    return {
      error: {
        name: this.name,
        message: this.message,
        code: this.code,
        statusCode: this.statusCode,
        stack: this.stack,
      },
      context: this.context,
      timestamp: this.timestamp.toISOString(),
      originalError: this.originalError
        ? {
            name: this.originalError.name,
            message: this.originalError.message,
          }
        : undefined,
    };
  }

  // Builder pattern methods that return new instances

  /**
   * Creates a new error instance with additional context merged into existing context.
   *
   * @param {Record<string, unknown>} context - Additional context to merge
   * @returns {this} New error instance with merged context
   *
   * @example
   * ```typescript
   * const error = new CertusAdiValtError('Error')
   *   .withContext({ userId: 123 })
   *   .withContext({ operation: 'create' });
   * // error.context = { userId: 123, operation: 'create' }
   * ```
   */
  public withContext(context: Record<string, unknown>): this {
    return this.clone({ context: { ...this.context, ...context } });
  }

  /**
   * Creates a new error instance with the specified error code.
   *
   * @param {string} code - New error code to use
   * @returns {this} New error instance with updated code
   *
   * @example
   * ```typescript
   * const error = new CertusAdiValtError('Error')
   *   .withCode('VALIDATION_ERROR');
   * ```
   */
  public withCode(code: string): this {
    return this.clone({ code });
  }

  /**
   * Creates a new error instance with the specified HTTP status code.
   *
   * @param {number} statusCode - New HTTP status code to use
   * @returns {this} New error instance with updated status code
   *
   * @example
   * ```typescript
   * const error = new CertusAdiValtError('Error')
   *   .withStatusCode(400);
   * ```
   */
  public withStatusCode(statusCode: number): this {
    return this.clone({ statusCode });
  }

  /**
   * Creates a new error instance with the specified error message.
   *
   * @param {string} message - New error message to use
   * @returns {this} New error instance with updated message
   *
   * @example
   * ```typescript
   * const error = new CertusAdiValtError('Initial')
   *   .withMessage('More specific error message');
   * ```
   */
  public withMessage(message: string): this {
    return this.clone({ message });
  }

  /**
   * Protected method to clone the error instance with overridden properties.
   * Used internally by builder pattern methods to create modified error instances.
   *
   * @protected
   * @param {Partial<{ message: string; code: string; statusCode: number; context: Record<string, unknown>; originalError?: Error; }>} overrides - Properties to override in the new instance
   * @returns {this} New error instance with applied overrides
   *
   * @remarks
   * - Preserves the original stack trace for better debugging
   * - Creates a new instance rather than modifying the existing one
   * - Maintains the same constructor chain for subclass compatibility
   *
   * @example
   * ```typescript
   * // In a subclass
   * protected clone(overrides: Partial<...>): this {
   *   const cloned = super.clone(overrides);
   *   // Add subclass-specific logic
   *   return cloned;
   * }
   * ```
   */
  protected clone(
    overrides: Partial<{
      message: string;
      code: string;
      statusCode: number;
      context: Record<string, unknown>;
      originalError?: Error;
    }>
  ): this {
    const Constructor = this.constructor as new (
      message: string,
      code: string,
      statusCode: number,
      context: Record<string, unknown>,
      originalError?: Error
    ) => this;

    const newError = new Constructor(
      overrides.message ?? this.message,
      overrides.code ?? this.code,
      overrides.statusCode ?? this.statusCode,
      overrides.context ?? { ...this.context },
      overrides.originalError ?? this.originalError
    );

    // Preserve stack trace
    newError.stack = this.stack;
    return newError;
  }
}
import { ErrorCodes, HttpStatus } from '@/constants';
import { CertusClientError } from './client';

/**
 * Base authentication error class for all authentication-related failures.
 *
 * Extends CertusClientError to provide specialized error handling for authentication scenarios.
 * Represents generic authentication failures that don't fit more specific error categories.
 *
 * @example
 * ```typescript
 * // Throw when authentication mechanism fails
 * throw new CertusAuthenticationError('Authentication provider unavailable');
 *
 * // With additional context
 * throw new CertusAuthenticationError(
 *   'Multi-factor authentication required',
 *   ErrorCodes.AUTH_MFA_REQUIRED,
 *   HttpStatus.UNAUTHORIZED,
 *   { mfaType: 'totp' }
 * );
 * ```
 */
export class CertusAuthenticationError extends CertusClientError {
  /**
   * Creates a new CertusAuthenticationError instance.
   *
   * @param {string} [message='Authentication failed'] - Human-readable error description
   * @param {string} [code=ErrorCodes.AUTH_INVALID_CREDENTIALS] - Machine-readable error code
   * @param {number} [statusCode=HttpStatus.UNAUTHORIZED] - HTTP status code (401 Unauthorized)
   * @param {Record<string, unknown>} [context={}] - Additional authentication context
   *
   * @example
   * ```typescript
   * // Default authentication error
   * throw new CertusAuthenticationError();
   *
   * // Custom authentication error
   * throw new CertusAuthenticationError(
   *   'Biometric authentication failed',
   *   ErrorCodes.AUTH_BIOMETRIC_FAILED,
   *   HttpStatus.UNAUTHORIZED,
   *   { device: 'fingerprint_scanner', attempts: 3 }
   * );
   * ```
   */
  constructor(
    message: string = 'Authentication failed',
    code: string = ErrorCodes.AUTH_INVALID_CREDENTIALS,
    statusCode: number = HttpStatus.UNAUTHORIZED,
    context: Record<string, unknown> = {}
  ) {
    super(message, code, statusCode, context);
    this.name = 'CertusAuthenticationError';
  }
}

/**
 * Error thrown when user credentials (username/password) are invalid or incorrect.
 *
 * Used for cases where the provided credentials don't match any user account
 * or fail validation checks (e.g., password complexity requirements).
 *
 * @example
 * ```typescript
 * // Validate user credentials
 * if (!await validateCredentials(username, password)) {
 *   throw new CertusInvalidCredentialsError(
 *     'Username or password is incorrect',
 *     { username, attemptCount: 3 }
 *   );
 * }
 *
 * // With builder pattern
 * throw new CertusInvalidCredentialsError()
 *   .withContext({ ip: '192.168.1.1', userAgent: 'Mozilla/5.0' });
 * ```
 */
export class CertusInvalidCredentialsError extends CertusAuthenticationError {
  /**
   * Creates a new CertusInvalidCredentialsError instance.
   *
   * @param {string} [message='Invalid credentials'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the credential failure
   *
   * @example
   * ```typescript
   * // Basic invalid credentials
   * throw new CertusInvalidCredentialsError();
   *
   * // With custom message and context
   * throw new CertusInvalidCredentialsError(
   *   'The password you entered is incorrect',
   *   {
   *     userId: 'user_123',
   *     lockoutRemaining: 15, // minutes
   *     failedAttempts: 2
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Invalid credentials', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.AUTH_INVALID_CREDENTIALS, HttpStatus.UNAUTHORIZED, context);
    this.name = 'CertusInvalidCredentialsError';
  }
}

/**
 * Error thrown when an authentication token (JWT, access token, etc.) has expired.
 *
 * Indicates that the token was valid but is no longer acceptable due to expiration.
 * Clients should typically request a new token using refresh token mechanisms.
 *
 * @example
 * ```typescript
 * // Check token expiration
 * if (token.expiresAt < Date.now()) {
 *   throw new CertusTokenExpiredError(
 *     'Your session has expired. Please log in again.',
 *     { tokenId: token.id, expiredAt: token.expiresAt }
 *   );
 * }
 *
 * // In token validation middleware
 * try {
 *   verifyToken(accessToken);
 * } catch (error) {
 *   if (error.name === 'TokenExpiredError') {
 *     throw new CertusTokenExpiredError()
 *       .withContext({ tokenType: 'access_token' });
 *   }
 * }
 * ```
 */
export class CertusTokenExpiredError extends CertusAuthenticationError {
  /**
   * Creates a new CertusTokenExpiredError instance.
   *
   * @param {string} [message='Token has expired'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the token expiration
   *
   * @example
   * ```typescript
   * // Default token expired error
   * throw new CertusTokenExpiredError();
   *
   * // With detailed context
   * throw new CertusTokenExpiredError(
   *   'Refresh token has expired',
   *   {
   *     tokenType: 'refresh_token',
   *     issuedAt: '2023-01-01T00:00:00Z',
   *     expiredAt: '2023-01-31T23:59:59Z',
   *     currentTime: '2023-02-01T10:30:00Z'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Token has expired', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.AUTH_TOKEN_EXPIRED, HttpStatus.UNAUTHORIZED, context);
    this.name = 'CertusTokenExpiredError';
  }
}

/**
 * Error thrown when a user lacks sufficient permissions to perform an action.
 *
 * Represents authorization failures where the user is authenticated but doesn't have
 * the required permissions, roles, or access levels for the requested operation.
 * Returns HTTP 403 Forbidden status code.
 *
 * @example
 * ```typescript
 * // Check user permissions
 * if (!user.hasPermission('delete_users')) {
 *   throw new CertusInsufficientPermissionsError(
 *     'You do not have permission to delete users',
 *     {
 *       requiredPermission: 'delete_users',
 *       userPermissions: user.permissions,
 *       resource: 'users'
 *     }
 *   );
 * }
 *
 * // Role-based access control
 * if (user.role !== 'admin') {
 *   throw new CertusInsufficientPermissionsError(
 *     'Admin role required to access this resource'
 *   );
 * }
 * ```
 */
export class CertusInsufficientPermissionsError extends CertusClientError {
  /**
   * Creates a new CertusInsufficientPermissionsError instance.
   *
   * @param {string} [message='Insufficient permissions'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the permission failure
   *
   * @example
   * ```typescript
   * // Basic insufficient permissions
   * throw new CertusInsufficientPermissionsError();
   *
   * // With detailed permission context
   * throw new CertusInsufficientPermissionsError(
   *   'Cannot access billing information',
   *   {
   *     userId: 'user_123',
   *     action: 'read',
   *     resource: 'billing',
   *     requiredRole: 'account_owner',
   *     userRole: 'team_member'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Insufficient permissions', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.AUTH_INSUFFICIENT_PERMISSIONS, HttpStatus.FORBIDDEN, context);
    this.name = 'CertusInsufficientPermissionsError';
  }
}

/**
 * Error thrown when a user's session has been explicitly revoked or invalidated.
 *
 * Indicates that the session was previously valid but has been manually terminated
 * by the user, administrator, or system (e.g., due to security concerns, logout from other device).
 *
 * @example
 * ```typescript
 * // Check session status
 * const session = await getSession(sessionId);
 * if (session.revoked) {
 *   throw new CertusSessionRevokedError(
 *     'This session was terminated by the user',
 *     {
 *       sessionId,
 *       revokedAt: session.revokedAt,
 *       revokedBy: session.revokedBy
 *     }
 *   );
 * }
 *
 * // In authentication middleware
 * if (await isSessionRevoked(token.sessionId)) {
 *   throw new CertusSessionRevokedError()
 *     .withContext({ reason: 'user_logged_out' });
 * }
 * ```
 */
export class CertusSessionRevokedError extends CertusAuthenticationError {
  /**
   * Creates a new CertusSessionRevokedError instance.
   *
   * @param {string} [message='Session has been revoked'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the session revocation
   *
   * @example
   * ```typescript
   * // Default session revoked error
   * throw new CertusSessionRevokedError();
   *
   * // With revocation details
   * throw new CertusSessionRevokedError(
   *   'Your account was logged out from another device',
   *   {
   *     sessionId: 'sess_abc123',
   *     revokedAt: '2023-01-15T14:30:00Z',
   *     revokedBy: 'user_action',
   *     device: 'Mobile App - iPhone'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Session has been revoked', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.AUTH_SESSION_REVOKED, HttpStatus.UNAUTHORIZED, context);
    this.name = 'CertusSessionRevokedError';
  }
}
import { ErrorCodes, HttpStatus } from '@/constants';
import { CertusAdiValtError } from './base';

/**
 * Base client error class for all client-side (4xx) errors.
 *
 * Represents errors that are the client's responsibility, such as invalid requests,
 * authentication issues, or missing resources. Extends CertusAdiValtError to provide
 * consistent error handling for all client-facing error scenarios.
 *
 * @example
 * ```typescript
 * // Custom client error
 * throw new CertusClientError('Invalid request parameters', 'CUSTOM_CLIENT_ERROR', 400);
 *
 * // With context for better debugging
 * throw new CertusClientError(
 *   'Request timeout',
 *   ErrorCodes.GEN_REQUEST_TIMEOUT,
 *   HttpStatus.REQUEST_TIMEOUT,
 *   { timeoutMs: 5000, endpoint: '/api/data' }
 * );
 * ```
 */
export class CertusClientError extends CertusAdiValtError {
  /**
   * Creates a new CertusClientError instance.
   *
   * @param {string} message - Human-readable error description
   * @param {string} [code=ErrorCodes.GEN_VALIDATION_ERROR] - Machine-readable error code
   * @param {number} [statusCode=HttpStatus.BAD_REQUEST] - HTTP status code (4xx range)
   * @param {Record<string, unknown>} [context={}] - Additional context about the client error
   *
   * @example
   * ```typescript
   * // Basic client error with default code and status
   * throw new CertusClientError('Invalid input provided');
   *
   * // Custom client error with specific code and status
   * throw new CertusClientError(
   *   'Payment required',
   *   ErrorCodes.GEN_PAYMENT_REQUIRED,
   *   HttpStatus.PAYMENT_REQUIRED,
   *   { plan: 'premium', feature: 'advanced_analytics' }
   * );
   * ```
   */
  constructor(
    message: string,
    code: string = ErrorCodes.GEN_VALIDATION_ERROR,
    statusCode: number = HttpStatus.BAD_REQUEST,
    context: Record<string, unknown> = {}
  ) {
    super(message, code, statusCode, context);
    this.name = 'CertusClientError';
  }
}

/**
 * Error thrown when input data fails validation rules.
 *
 * Represents schema validation failures, data type mismatches, or business rule violations.
 * Typically returns HTTP 422 Unprocessable Entity to indicate semantically invalid data.
 *
 * @example
 * ```typescript
 * // Validate user input
 * const validation = validateUserInput(data);
 * if (!validation.isValid) {
 *   throw new CertusValidationError(
 *     'User data validation failed',
 *     { errors: validation.errors, field: 'email' }
 *   );
 * }
 *
 * // In API request validation
 * if (!isValidEmail(request.body.email)) {
 *   throw new CertusValidationError('Invalid email format')
 *     .withContext({ value: request.body.email, pattern: 'email-regex' });
 * }
 * ```
 */
export class CertusValidationError extends CertusClientError {
  /**
   * Creates a new CertusValidationError instance.
   *
   * @param {string} [message='Validation failed'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about validation failures
   *
   * @example
   * ```typescript
   * // Basic validation error
   * throw new CertusValidationError();
   *
   * // Detailed validation error with multiple issues
   * throw new CertusValidationError(
   *   'Multiple validation errors occurred',
   *   {
   *     validationErrors: [
   *       { field: 'email', message: 'Must be a valid email address' },
   *       { field: 'password', message: 'Must be at least 8 characters' }
   *     ],
   *     receivedData: { email: 'invalid', password: 'short' }
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Validation failed', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.VAL_INVALID_INPUT, HttpStatus.UNPROCESSABLE_ENTITY, context);
    this.name = 'CertusValidationError';
  }
}

/**
 * Error thrown when a requested resource cannot be found.
 *
 * Used for cases where the client requests a resource that doesn't exist or
 * the user doesn't have access to. Returns HTTP 404 Not Found status code.
 *
 * @example
 * ```typescript
 * // Lookup resource by ID
 * const user = await userRepository.findById(userId);
 * if (!user) {
 *   throw new CertusNotFoundError(
 *     `User with ID ${userId} not found`,
 *     { resource: 'User', id: userId, searchedBy: 'id' }
 *   );
 * }
 *
 * // In REST API endpoint
 * if (!await database.exists('products', productId)) {
 *   throw new CertusNotFoundError('Product not found')
 *     .withContext({ productId, catalog: 'electronics' });
 * }
 * ```
 */
export class CertusNotFoundError extends CertusClientError {
  /**
   * Creates a new CertusNotFoundError instance.
   *
   * @param {string} [message='Resource not found'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the missing resource
   *
   * @example
   * ```typescript
   * // Basic not found error
   * throw new CertusNotFoundError();
   *
   * // Specific resource not found
   * throw new CertusNotFoundError(
   *   'Order not found in system',
   *   {
   *     resourceType: 'Order',
   *     resourceId: 'ord_123456',
   *     searchedFields: ['id', 'reference'],
   *     availableResources: ['users', 'products', 'categories']
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Resource not found', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.GEN_NOT_FOUND, HttpStatus.NOT_FOUND, context);
    this.name = 'CertusNotFoundError';
  }
}

/**
 * Error thrown when authentication is required but not provided or invalid.
 *
 * Represents cases where the client needs to authenticate but hasn't provided
 * valid credentials. Returns HTTP 401 Unauthorized status code.
 *
 * @example
 * ```typescript
 * // Check authentication in middleware
 * if (!request.headers.authorization) {
 *   throw new CertusUnauthorizedError(
 *     'Authentication required to access this resource',
 *     { endpoint: request.path, method: request.method }
 *   );
 * }
 *
 * // Validate API key
 * if (!isValidApiKey(apiKey)) {
 *   throw new CertusUnauthorizedError('Invalid API key')
 *     .withContext({ keyType: 'public', format: 'bearer' });
 * }
 * ```
 */
export class CertusUnauthorizedError extends CertusClientError {
  /**
   * Creates a new CertusUnauthorizedError instance.
   *
   * @param {string} [message='Unauthorized access'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the authorization failure
   *
   * @example
   * ```typescript
   * // Basic unauthorized error
   * throw new CertusUnauthorizedError();
   *
   * // Specific unauthorized scenario
   * throw new CertusUnauthorizedError(
   *   'Bearer token missing or invalid',
   *   {
   *     authScheme: 'Bearer',
   *     providedHeader: request.headers.authorization,
   *     expectedFormat: 'Bearer <token>',
   *     documentation: 'https://api.example.com/docs/authentication'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Unauthorized access', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.AUTH_UNAUTHORIZED, HttpStatus.UNAUTHORIZED, context);
    this.name = 'CertusUnauthorizedError';
  }
}

/**
 * Error thrown when the client is authenticated but lacks permission for the requested action.
 *
 * Represents authorization failures where the client has valid credentials but isn't
 * allowed to perform the specific operation. Returns HTTP 403 Forbidden status code.
 *
 * @example
 * ```typescript
 * // Check user role permissions
 * if (user.role !== 'admin' && requestedAction === 'delete_users') {
 *   throw new CertusForbiddenError(
 *     'Only administrators can delete users',
 *     { userRole: user.role, requiredRole: 'admin', action: 'delete_users' }
 *   );
 * }
 *
 * // Check resource ownership
 * if (resource.ownerId !== user.id && !user.isModerator) {
 *   throw new CertusForbiddenError('You can only modify your own resources')
 *     .withContext({ resourceOwner: resource.ownerId, currentUser: user.id });
 * }
 * ```
 */
export class CertusForbiddenError extends CertusClientError {
  /**
   * Creates a new CertusForbiddenError instance.
 import { ErrorCodes, HttpStatus } from '@/constants';
import { CertusServerError } from './server';

/**
 * Base database error class for all database-related failures.
 *
 * Represents errors that occur during database operations such as query execution,
 * connection issues, or constraint violations. Extends CertusServerError to provide
 * specialized handling for database-specific error scenarios.
 *
 * @example
 * ```typescript
 * // Catch and wrap database errors
 * try {
 *   await database.query('INSERT INTO users ...');
 * } catch (error) {
 *   throw new CertusDatabaseError(
 *     'Failed to create user record',
 *     ErrorCodes.DB_QUERY_ERROR,
 *     HttpStatus.INTERNAL_SERVER_ERROR,
 *     { table: 'users', operation: 'insert', originalError: error }
 *   );
 * }
 *
 * // Custom database error
 * throw new CertusDatabaseError('Database migration failed')
 *   .withContext({ migration: 'v2_add_indexes', step: 'creating_indexes' });
 * ```
 */
export class CertusDatabaseError extends CertusServerError {
  /**
   * Creates a new CertusDatabaseError instance.
   *
   * @param {string} [message='Database error occurred'] - Human-readable error description
   * @param {string} [code=ErrorCodes.DB_QUERY_ERROR] - Machine-readable error code for database failures
   * @param {number} [statusCode=HttpStatus.INTERNAL_SERVER_ERROR] - HTTP status code (5xx range)
   * @param {Record<string, unknown>} [context={}] - Additional context about the database error
   *
   * @example
   * ```typescript
   * // Default database error
   * throw new CertusDatabaseError();
   *
   * // Specific database error with context
   * throw new CertusDatabaseError(
   *   'Failed to execute complex join query',
   *   ErrorCodes.DB_QUERY_ERROR,
   *   HttpStatus.INTERNAL_SERVER_ERROR,
   *   {
   *     query: 'SELECT * FROM users JOIN orders ...',
   *     tables: ['users', 'orders', 'products'],
   *     database: 'production_db',
   *     executionTime: '2.5s'
   *   }
   * );
   * ```
   */
  constructor(
    message: string = 'Database error occurred',
    code: string = ErrorCodes.DB_QUERY_ERROR,
    statusCode: number = HttpStatus.INTERNAL_SERVER_ERROR,
    context: Record<string, unknown> = {}
  ) {
    super(message, code, statusCode, context);
    this.name = 'CertusDatabaseError';
  }
}

/**
 * Error thrown when a database unique constraint violation occurs.
 *
 * Represents cases where an insert or update operation would violate a unique
 * constraint (e.g., duplicate email, duplicate username). Returns HTTP 409 Conflict
 * status code to indicate the request conflicts with current state.
 *
 * @example
 * ```typescript
 * // Handle unique email constraint
 * try {
 *   await userRepository.create({ email: 'user@example.com' });
 * } catch (error) {
 *   if (error.code === '23505') { // PostgreSQL unique violation
 *     throw new CertusUniqueConstraintError(
 *       'Email address already registered',
 *       { field: 'email', value: 'user@example.com', constraint: 'users_email_key' }
 *     );
 *   }
 * }
 *
 * // Check for duplicate usernames
 * if (await usernameExists(username)) {
 *   throw new CertusUniqueConstraintError('Username already taken')
 *     .withContext({ field: 'username', value: username, suggestion: `${username}123` });
 * }
 * ```
 */
export class CertusUniqueConstraintError extends CertusDatabaseError {
  /**
   * Creates a new CertusUniqueConstraintError instance.
   *
   * @param {string} [message='Unique constraint violation'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the constraint violation
   *
   * @example
   * ```typescript
   * // Basic unique constraint error
   * throw new CertusUniqueConstraintError();
   *
   * // Detailed constraint violation
   * throw new CertusUniqueConstraintError(
   *   'Product SKU must be unique',
   *   {
   *     table: 'products',
   *     constraint: 'products_sku_unique',
   *     conflictingField: 'sku',
   *     conflictingValue: 'PROD-12345',
   *     existingRecordId: 'prod_abc123',
   *     suggestion: 'Use a different SKU or update existing product'
   *   }
   * );
   * ```
   */
  constructor(
    message: string = 'Unique constraint violation',
    context: Record<string, unknown> = {}
  ) {
    super(message, ErrorCodes.DB_UNIQUE_CONSTRAINT, HttpStatus.CONFLICT, context);
    this.name = 'CertusUniqueConstraintError';
  }
}

/**
 * Error thrown when database connection issues occur.
 *
 * Represents failures in establishing or maintaining database connections,
 * including connection timeouts, authentication failures, or database unavailability.
 * Returns HTTP 503 Service Unavailable status code.
 *
 * @example
 * ```typescript
 * // Database connection health check
 * if (!await database.isConnected()) {
 *   throw new CertusConnectionError(
 *     'Unable to connect to database',
 *     {
 *       host: config.database.host,
 *       port: config.database.port,
 *       database: config.database.name,
 *       retryCount: 3
 *     }
 *   );
 * }
 *
 * // Connection pool exhaustion
 * if (connectionPool.isFull()) {
 *   throw new CertusConnectionError('Database connection pool exhausted')
 *     .withContext({ maxConnections: 100, activeConnections: 100, waitQueue: 15 });
 * }
 * ```
 */
export class CertusConnectionError extends CertusDatabaseError {
  /**
   * Creates a new CertusConnectionError instance.
   *
   * @param {string} [message='Database connection error'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the connection failure
   *
   * @example
   * ```typescript
   * // Basic connection error
   * throw new CertusConnectionError();
   *
   * // Detailed connection failure
   * throw new CertusConnectionError(
   *   'Database authentication failed',
   *   {
   *     databaseType: 'PostgreSQL',
   *     host: 'db-cluster.example.com',
   *     port: 5432,
   *     database: 'app_production',
   *     username: 'app_user',
   *     errorCode: '28P01', // PostgreSQL invalid password
   *     suggestion: 'Check database credentials and network connectivity'
   *   }
   * );
   * ```
   */
  constructor(
    message: string = 'Database connection error',
    context: Record<string, unknown> = {}
  ) {
    super(message, ErrorCodes.DB_CONNECTION_ERROR, HttpStatus.SERVICE_UNAVAILABLE, context);
    this.name = 'CertusConnectionError';
  }
}

/**
 * Error thrown when database operations exceed their time limits.
 *
 * Represents cases where queries, transactions, or other database operations
 * take longer than the configured timeout period. Returns HTTP 504 Gateway Timeout
 * status code to indicate the operation didn't complete in time.
 *
 * @example
 * ```typescript
 * // Query with timeout
 * try {
 *   const result = await database.query({
 *     text: 'SELECT * FROM large_table WHERE ...',
 *     timeout: 5000 // 5 seconds
 *   });
 * } catch (error) {
 *   if (error.code === '57014') { // PostgreSQL query canceled
 *     throw new CertusTimeoutError(
 *       'Database query exceeded time limit',
 *       { query: 'complex_aggregation', timeoutMs: 5000, table: 'large_table' }
 *     );
 *   }
 * }
 *
 * // Long-running transaction timeout
 * if (transaction.elapsedTime > MAX_TRANSACTION_TIME) {
 *   throw new CertusTimeoutError('Transaction timeout exceeded')
 *     .withContext({ transactionId: transaction.id, maxDuration: '30s', elapsed: '45s' });
 * }
 * ```
 */
export class CertusTimeoutError extends CertusDatabaseError {
  /**
   * Creates a new CertusTimeoutError instance.
   *
   * @param {string} [message='Database operation timed out'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the timeout
   *
   * @example
   * ```typescript
   * // Basic timeout error
   * throw new CertusTimeoutError();
   *
   * // Detailed timeout information
   * throw new CertusTimeoutError(
   *   'Complex analytics query timed out',
   *   {
   *     operation: 'analytics_aggregation',
   *     timeoutLimit: '30 seconds',
   *     actualDuration: '35 seconds',
   *     queryComplexity: 'high',
   *     tablesInvolved: ['events', 'users', 'products'],
   *     rowCount: '1.5M rows',
   *     suggestion: 'Optimize query, add indexes, or use pagination'
   *   }
   * );
   * ```
   */
  constructor(
    message: string = 'Database operation timed out',
    context: Record<string, unknown> = {}
  ) {
    super(message, ErrorCodes.DB_TIMEOUT_ERROR, HttpStatus.GATEWAY_TIMEOUT, context);
    this.name = 'CertusTimeoutError';
  }
}
 *
   * @param {string} [message='Access forbidden'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the permission denial
   *
   * @example
   * ```typescript
   * // Basic forbidden error
   * throw new CertusForbiddenError();
   *
   * // Detailed permission denial
   * throw new CertusForbiddenError(
   *   'Insufficient subscription level for this feature',
   *   {
   *     userSubscription: 'basic',
   *     requiredSubscription: 'premium',
   *     feature: 'advanced_analytics',
   *     upgradeUrl: '/billing/upgrade'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Access forbidden', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.AUTH_INSUFFICIENT_PERMISSIONS, HttpStatus.FORBIDDEN, context);
    this.name = 'CertusForbiddenError';
  }
}
import { ErrorCodes, HttpStatus } from '@/constants';
import { CertusAdiValtError } from './base';

/**
 * Base server error class for all server-side (5xx) errors.
 *
 * Represents errors that are the server's responsibility, such as internal processing failures,
 * external service dependencies, or configuration issues. Extends CertusAdiValtError to provide
 * consistent error handling for all server-side error scenarios that clients cannot fix.
 *
 * @example
 * ```typescript
 * // Custom server error for business logic failures
 * throw new CertusServerError(
 *   'Failed to process payment workflow',
 *   ErrorCodes.SRV_PROCESSING_ERROR,
 *   HttpStatus.INTERNAL_SERVER_ERROR,
 *   { workflow: 'payment_processing', step: 'fraud_check' }
 * );
 *
 * // Wrap unexpected errors in server error
 * try {
 *   complexBusinessOperation();
 * } catch (error) {
 *   throw new CertusServerError(
 *     'Unexpected error during operation',
 *     ErrorCodes.SRV_UNEXPECTED_ERROR,
 *     HttpStatus.INTERNAL_SERVER_ERROR,
 *     { operation: 'complex_business_operation', originalError: error }
 *   );
 * }
 */
export class CertusServerError extends CertusAdiValtError {
  /**
   * Creates a new CertusServerError instance.
   *
   * @param {string} message - Human-readable error description
   * @param {string} [code=ErrorCodes.SRV_INTERNAL_ERROR] - Machine-readable error code for server failures
   * @param {number} [statusCode=HttpStatus.INTERNAL_SERVER_ERROR] - HTTP status code (5xx range)
   * @param {Record<string, unknown>} [context={}] - Additional context about the server error
   *
   * @example
   * ```typescript
   * // Basic server error with default code and status
   * throw new CertusServerError('Unexpected server failure');
   *
   * // Specific server error with detailed context
   * throw new CertusServerError(
   *   'Data processing pipeline failed',
   *   ErrorCodes.SRV_PROCESSING_ERROR,
   *   HttpStatus.INTERNAL_SERVER_ERROR,
   *   {
   *     pipeline: 'data_enrichment',
   *     stage: 'normalization',
   *     recordsProcessed: 1500,
   *     failedAt: 'data_validation',
   *     retryAttempt: 2
   *   }
   * );
   * ```
   */
  constructor(
    message: string,
    code: string = ErrorCodes.SRV_INTERNAL_ERROR,
    statusCode: number = HttpStatus.INTERNAL_SERVER_ERROR,
    context: Record<string, unknown> = {}
  ) {
    super(message, code, statusCode, context);
    this.name = 'CertusServerError';
  }
}

/**
 * Error thrown for generic internal server errors when no more specific error applies.
 *
 * Represents unexpected failures in the application logic, unhandled exceptions, or
 * scenarios where the root cause cannot be determined. Returns HTTP 500 Internal Server Error.
 * This should be used as a fallback when no other specific server error class fits.
 *
 * @example
 * ```typescript
 * // Catch-all for unexpected errors
 * try {
 *   await businessCriticalOperation();
 * } catch (error) {
 *   if (error instanceof CertusAdiValtError) {
 *     throw error; // Re-throw known errors
 *   }
 *   // Wrap unknown errors
 *   throw new CertusInternalServerError(
 *     'An unexpected error occurred',
 *     { operation: 'business_critical_operation', originalError: error.message }
 *   );
 * }
 *
 * // Fallback error handler
 * if (result === undefined && !isExpectedScenario) {
 *   throw new CertusInternalServerError('Unexpected undefined result')
 *     .withContext({ function: 'calculateBusinessMetrics', input: processedData });
 * }
 * ```
 */
export class CertusInternalServerError extends CertusServerError {
  /**
   * Creates a new CertusInternalServerError instance.
   *
   * @param {string} [message='Internal server error'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the internal error
   *
   * @example
   * ```typescript
   * // Basic internal server error
   * throw new CertusInternalServerError();
   *
   * // Detailed internal error with debugging information
   * throw new CertusInternalServerError(
   *   'Critical business logic failure',
   *   {
   *     component: 'order_processing',
   *     method: 'calculateTax',
   *     input: { amount: 100, country: 'US' },
   *     stackTrace: '...',
   *     server: 'web-01',
   *     timestamp: new Date().toISOString(),
   *     incidentId: 'inc_123456'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Internal server error', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.SRV_INTERNAL_ERROR, HttpStatus.INTERNAL_SERVER_ERROR, context);
    this.name = 'CertusInternalServerError';
  }
}

/**
 * Error thrown when external service dependencies fail or return errors.
 *
 * Represents failures in third-party API calls, microservice dependencies, or
 * external resource access. Returns HTTP 502 Bad Gateway status code to indicate
 * the server received an invalid response from an upstream server.
 *
 * @example
 * ```typescript
 * // External API call failure
 * try {
 *   const paymentResult = await paymentGateway.charge(amount, token);
 * } catch (error) {
 *   throw new CertusExternalServiceError(
 *     'Payment gateway unavailable',
 *     {
 *       service: 'stripe_payment_gateway',
 *       operation: 'charge',
 *       error: error.message,
 *       retryCount: 3,
 *       timeout: '30s'
 *     }
 *   );
 * }
 *
 * // Microservice dependency failure
 * const userServiceResponse = await fetchUserService(userId);
 * if (userServiceResponse.status >= 500) {
 *   throw new CertusExternalServiceError('User service temporarily unavailable')
 *     .withContext({ service: 'user_service', status: userServiceResponse.status });
 * }
 * ```
 */
export class CertusExternalServiceError extends CertusServerError {
  /**
   * Creates a new CertusExternalServiceError instance.
   *
   * @param {string} [message='External service error'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the external service failure
   *
   * @example
   * ```typescript
   * // Basic external service error
   * throw new CertusExternalServiceError();
   *
   * // Detailed external service failure
   * throw new CertusExternalServiceError(
   *   'Email service delivery failed',
   *   {
   *     externalService: 'sendgrid',
   *     endpoint: '/v3/mail/send',
   *     statusCode: 503,
   *     errorResponse: { errors: ['Service temporarily unavailable'] },
   *     requestId: 'sendgrid_req_123',
   *     retryAttempts: 2,
   *     suggestion: 'Check SendGrid status page or use fallback provider'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'External service error', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.SRV_EXTERNAL_SERVICE, HttpStatus.BAD_GATEWAY, context);
    this.name = 'CertusExternalServiceError';
  }
}

/**
 * Error thrown when application configuration is invalid, missing, or misconfigured.
 *
 * Represents failures due to incorrect environment variables, invalid configuration files,
 * or missing required settings. Returns HTTP 500 Internal Server Error since configuration
 * issues prevent the application from functioning properly.
 *
 * @example
 * ```typescript
 * // Validate required configuration
 * if (!process.env.DATABASE_URL) {
 *   throw new CertusConfigurationError(
 *     'Database connection string is required',
 *     { missingVariable: 'DATABASE_URL', environment: process.env.NODE_ENV }
 *   );
 * }
 *
 * // Validate configuration format
 * if (!isValidApiKeyFormat(config.paymentGateway.apiKey)) {
 *   throw new CertusConfigurationError('Invalid payment gateway API key format')
 *     .withContext({
 *       configSection: 'paymentGateway',
 *       field: 'apiKey',
 *       expectedFormat: 'sk_live_...',
 *       actualValue: config.paymentGateway.apiKey?.substring(0, 8) + '...'
 *     });
 * }
 * ```
 */
export class CertusConfigurationError extends CertusServerError {
  /**
   * Creates a new CertusConfigurationError instance.
   *
   * @param {string} [message='Configuration error'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about the configuration issue
   *
   * @example
   * ```typescript
   * // Basic configuration error
   * throw new CertusConfigurationError();
   *
   * // Detailed configuration validation failure
   * throw new CertusConfigurationError(
   *   'Invalid database configuration',
   *   {
   *     configFile: 'database.config.js',
   *     validationErrors: [
   *       { field: 'pool.max', issue: 'Must be a positive integer', value: -1 },
   *       { field: 'ssl', issue: 'Must be boolean or object', value: 'true' }
   *     ],
   *     environment: 'production',
   *     suggestion: 'Check environment variables and config file syntax'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Configuration error', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.SRV_CONFIGURATION_ERROR, HttpStatus.INTERNAL_SERVER_ERROR, context);
    this.name = 'CertusConfigurationError';
  }
}
import { ErrorCodes, HttpStatus } from '@/constants';
import { CertusClientError } from './client';

/**
 * Error thrown when input data fails basic validation rules.
 *
 * Represents failures in input validation such as required field checks, format validation,
 * type checking, or basic data integrity rules. Returns HTTP 400 Bad Request status code
 * to indicate the client should modify the request before retrying.
 *
 * @example
 * ```typescript
 * // Validate required fields
 * if (!input.email || !input.password) {
 *   throw new CertusInputValidationError(
 *     'Email and password are required',
 *     { missingFields: ['email', 'password'], received: Object.keys(input) }
 *   );
 * }
 *
 * // Validate input format
 * if (input.age && (input.age < 0 || input.age > 150)) {
 *   throw new CertusInputValidationError('Age must be between 0 and 150')
 *     .withContext({ field: 'age', value: input.age, validRange: [0, 150] });
 * }
 *
 * // Multiple validation failures
 * const errors = validateUserInput(input);
 * if (errors.length > 0) {
 *   throw new CertusInputValidationError('Multiple input validation errors')
 *     .withContext({ validationErrors: errors });
 * }
 * ```
 */
export class CertusInputValidationError extends CertusClientError {
  /**
   * Creates a new CertusInputValidationError instance.
   *
   * @param {string} [message='Input validation failed'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about validation failures
   *
   * @example
   * ```typescript
   * // Basic input validation error
   * throw new CertusInputValidationError();
   *
   * // Detailed input validation with multiple issues
   * throw new CertusInputValidationError(
   *   'User registration data invalid',
   *   {
   *     validationResults: [
   *       { field: 'email', issue: 'Invalid format', value: 'invalid-email' },
   *       { field: 'password', issue: 'Too short', value: '***', minLength: 8 },
   *       { field: 'birthDate', issue: 'Future date', value: '2030-01-01' }
   *     ],
   *     totalErrors: 3,
   *     suggestion: 'Review the API documentation for field requirements'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Input validation failed', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.VAL_INVALID_INPUT, HttpStatus.BAD_REQUEST, context);
    this.name = 'CertusInputValidationError';
  }
}

/**
 * Error thrown when data fails schema validation against a defined schema.
 *
 * Represents failures in structural validation using JSON Schema, Zod, Yup, or other
 * schema validation libraries. Returns HTTP 422 Unprocessable Entity status code to
 * indicate the request syntax is correct but semantic validation failed.
 *
 * @example
 * ```typescript
 * // JSON Schema validation
 * const validation = jsonSchema.validate(input);
 * if (!validation.valid) {
 *   throw new CertusSchemaValidationError(
 *     'Data does not match expected schema',
 *     {
 *       schema: 'user-registration',
 *       errors: validation.errors,
 *       received: input
 *     }
 *   );
 * }
 *
 * // Zod schema validation
 * const result = userSchema.safeParse(input);
 * if (!result.success) {
 *   throw new CertusSchemaValidationError('Schema validation failed')
 *     .withContext({
 *       schema: 'userSchema',
 *       zodErrors: result.error.format(),
 *       issues: result.error.issues
 *     });
 * }
 *
 * // API request body validation
 * const validation = await validateRequestBody(schema, request.body);
 * if (!validation.isValid) {
 *   throw new CertusSchemaValidationError('Request body validation failed', {
 *     schemaName: 'CreateUserRequest',
 *     validationErrors: validation.errors,
 *     path: request.path
 *   });
 * }
 * ```
 */
export class CertusSchemaValidationError extends CertusClientError {
  /**
   * Creates a new CertusSchemaValidationError instance.
   *
   * @param {string} [message='Schema validation failed'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about schema validation failures
   *
   * @example
   * ```typescript
   * // Basic schema validation error
   * throw new CertusSchemaValidationError();
   *
   * // Detailed schema validation failure
   * throw new CertusSchemaValidationError(
   *   'API request validation failed',
   *   {
   *     schema: 'OrderCreationSchema',
   *     validationLibrary: 'Joi',
   *     errors: [
   *       {
   *         path: ['items', 0, 'quantity'],
   *         message: '"quantity" must be greater than 0',
   *         type: 'number.min',
   *         value: -1
   *       },
   *       {
   *         path: ['shippingAddress', 'country'],
   *         message: '"country" must be one of [US, CA, EU]',
   *         type: 'any.only',
   *         value: 'XX'
   *       }
   *     ],
   *     documentation: 'https://api.example.com/schemas/order-creation'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Schema validation failed', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.VAL_SCHEMA_ERROR, HttpStatus.UNPROCESSABLE_ENTITY, context);
    this.name = 'CertusSchemaValidationError';
  }
}

/**
 * Error thrown when business rules or domain logic constraints are violated.
 *
 * Represents failures in business logic validation that go beyond simple data validation.
 * These errors enforce domain-specific rules and constraints. Returns HTTP 409 Conflict
 * status code to indicate the request conflicts with business rules or current state.
 *
 * @example
 * ```typescript
 * // Business rule: Cannot withdraw more than account balance
 * if (withdrawalAmount > accountBalance) {
 *   throw new CertusBusinessRuleError(
 *     'Insufficient funds for withdrawal',
 *     {
 *       accountBalance,
 *       withdrawalAmount,
 *       deficit: withdrawalAmount - accountBalance,
 *       rule: 'withdrawal_amount_lt_balance'
 *     }
 *   );
 * }
 *
 * // Business rule: Cannot cancel shipped order
 * if (order.status === 'shipped') {
 *   throw new CertusBusinessRuleError('Cannot cancel shipped order')
 *     .withContext({
 *       orderId: order.id,
 *       currentStatus: order.status,
 *       allowedStatuses: ['pending', 'confirmed'],
 *       businessRule: 'cancel_only_before_shipping'
 *     });
 * }
 *
 * // Domain constraint: Unique business identifier
 * if (await isBusinessIdentifierTaken(companyTaxId)) {
 *   throw new CertusBusinessRuleError('Company tax ID already registered')
 *     .withContext({
 *       taxId: companyTaxId,
 *       existingCompany: await findCompanyByTaxId(companyTaxId),
 *       rule: 'unique_tax_identifier'
 *     });
 * }
 * ```
 */
export class CertusBusinessRuleError extends CertusClientError {
  /**
   * Creates a new CertusBusinessRuleError instance.
   *
   * @param {string} [message='Business rule violation'] - Human-readable error description
   * @param {Record<string, unknown>} [context={}] - Additional context about business rule violations
   *
   * @example
   * ```typescript
   * // Basic business rule error
   * throw new CertusBusinessRuleError();
   *
   * // Complex business rule violation
   * throw new CertusBusinessRuleError(
   *   'Promotion usage limit exceeded',
   *   {
   *     promotionCode: 'SUMMER25',
   *     usageLimit: 5,
   *     currentUsage: 5,
   *     userId: 'user_123',
   *     businessRules: [
   *       'max_uses_per_customer',
   *       'promotion_active_period'
   *     ],
   *     validFrom: '2024-06-01',
   *     validTo: '2024-08-31',
   *     suggestion: 'Use a different promotion code or wait for reset'
   *   }
   * );
   * ```
   */
  constructor(message: string = 'Business rule violation', context: Record<string, unknown> = {}) {
    super(message, ErrorCodes.VAL_BUSINESS_RULE, HttpStatus.CONFLICT, context);
    this.name = 'CertusBusinessRuleError';
  }
}
import { CertusAdiValtError } from '../errors';

/**
 * Type guard to check if an unknown value is a CertusAdiValtError instance.
 *
 * This function provides runtime type checking to safely determine if an error
 * object is an instance of the CertusAdiValtError class or its subclasses.
 *
 * @param {unknown} error - The value to check, typically from a catch block
 * @returns {error is CertusAdiValtError} True if the value is a CertusAdiValtError instance
 *
 * @example
 * ```typescript
 * try {
 *   await someOperation();
 * } catch (error) {
 *   if (isCertusError(error)) {
 *     // TypeScript now knows error is CertusAdiValtError
 *     console.log(error.code); // Safe access to CertusAdiValtError properties
 *     console.log(error.statusCode);
 *   } else {
 *     // Handle non-Certus errors
 *     console.error('Unknown error type:', error);
 *   }
 * }
 *
 * // In error middleware
 * if (isCertusError(err)) {
 *   return res.status(err.statusCode).json(err.toJSON());
 * }
 * ```
 */
export function isCertusError(error: unknown): error is CertusAdiValtError {
  return error instanceof CertusAdiValtError;
}

/**
 * Checks if an error is a client error (4xx status code range).
 *
 * Client errors indicate that the request contains bad syntax or cannot be fulfilled
 * due to client-side issues. These errors are typically the client's responsibility to fix.
 *
 * @param {unknown} error - The error to check
 * @returns {boolean} True if the error is a CertusAdiValtError with 4xx status code
 *
 * @example
 * ```typescript
 * try {
 *   await apiCall();
 * } catch (error) {
 *   if (isClientError(error)) {
 *     // Handle client-side issues (validation, authentication, etc.)
 *     showUserErrorMessage(error.message);
 *   } else {
 *     // Handle server errors differently
 *     showGenericErrorMessage();
 *   }
 * }
 *
 * // In API error handling
 * if (isClientError(error)) {
 *   logger.warn('Client error:', error.toLog());
 * } else {
 *   logger.error('Server error:', error.toLog());
 * }
 * ```
 */
export function isClientError(error: unknown): boolean {
  return isCertusError(error) && error.statusCode >= 400 && error.statusCode < 500;
}

/**
 * Checks if an error is a server error (5xx status code range).
 *
 * Server errors indicate that the server failed to fulfill a valid request.
 * These errors are typically the server's responsibility and may require administrative action.
 *
 * @param {unknown} error - The error to check
 * @returns {boolean} True if the error is a CertusAdiValtError with 5xx status code
 *
 * @example
 * ```typescript
 * try {
 *   await processUserRequest();
 * } catch (error) {
 *   if (isServerError(error)) {
 *     // Alert operations team for server issues
 *     sendAlertToOpsTeam(error);
 *     return createServerErrorResponse();
 *   }
 *   // Handle client errors normally
 *   return createClientErrorResponse(error);
 * }
 *
 * // In monitoring systems
 * if (isServerError(error)) {
 *   metrics.increment('server_errors');
 *   if (error.statusCode === 503) {
 *     metrics.increment('service_unavailable_errors');
 *   }
 * }
 * ```
 */
export function isServerError(error: unknown): boolean {
  return isCertusError(error) && error.statusCode >= 500;
}

/**
 * Checks if an error is an authentication-related error.
 *
 * Authentication errors typically involve issues with user identity verification,
 * such as invalid credentials, expired tokens, or missing authentication.
 *
 * @param {unknown} error - The error to check
 * @returns {boolean} True if the error is a CertusAdiValtError with AUTH_ prefix error code
 *
 * @example
 * ```typescript
 * // In authentication middleware
 * try {
 *   await authenticateUser(request);
 * } catch (error) {
 *   if (isAuthenticationError(error)) {
 *     // Clear invalid session and prompt re-authentication
 *     clearUserSession();
 *     return redirectToLogin();
 *   }
 *   throw error; // Re-throw non-authentication errors
 * }
 *
 * // In client-side error handling
 * if (isAuthenticationError(error)) {
 *   // Show login modal or redirect to authentication flow
 *   showAuthenticationModal();
 * } else {
 *   // Show generic error message for other error types
 *   showErrorNotification(error.message);
 * }
 * ```
 */
export function isAuthenticationError(error: unknown): boolean {
  return isCertusError(error) && error.code.startsWith('AUTH_');
}

/**
 * Checks if an error is a validation-related error.
 *
 * Validation errors occur when input data fails to meet required criteria,
 * such as schema validation, business rules, or input format requirements.
 *
 * @param {unknown} error - The error to check
 * @returns {boolean} True if the error is a CertusAdiValtError with VAL_ prefix error code
 *
 * @example
 * ```typescript
 * // In form submission handling
 * try {
 *   await submitFormData(formData);
 * } catch (error) {
 *   if (isValidationError(error)) {
 *     // Extract validation details and show field-specific errors
 *     const fieldErrors = extractValidationErrors(error);
 *     highlightInvalidFields(fieldErrors);
 *     return;
 *   }
 *   // Handle non-validation errors
 *   showGenericError();
 * }
 *
 * // In API input validation
 * if (isValidationError(error)) {
 *   // Return detailed validation errors to help clients fix their requests
 *   return response.status(422).json({
 *     error: 'Validation failed',
 *     details: error.context.validationErrors
 *   });
 * }
 * ```
 */
export function isValidationError(error: unknown): boolean {
  return isCertusError(error) && error.code.startsWith('VAL_');
}

/**
 * Checks if an error is a database-related error.
 *
 * Database errors involve issues with data persistence operations,
 * such as connection failures, query errors, constraint violations, or timeouts.
 *
 * @param {unknown} error - The error to check
 * @returns {boolean} True if the error is a CertusAdiValtError with DB_ prefix error code
 *
 * @example
 * ```typescript
 * // In data access layer
 * try {
 *   await userRepository.save(user);
 * } catch (error) {
 *   if (isDatabaseError(error)) {
 *     // Implement database-specific recovery strategies
 *     if (error.code === 'DB_CONNECTION_ERROR') {
 *       await reconnectToDatabase();
 *       return retryOperation();
 *     }
 *     // Log database errors for DBA review
 *     logger.error('Database operation failed:', error.toLog());
 *   }
 *   throw error;
 * }
 *
 * // In health checks
 * if (isDatabaseError(error)) {
 *   healthStatus.database = 'unhealthy';
 *   triggerDatabaseFailover();
 * }
 * ```
 */
export function isDatabaseError(error: unknown): boolean {
  return isCertusError(error) && error.code.startsWith('DB_');
}

/**
 * Checks if an error is specifically an external service error.
 *
 * External service errors occur when dependencies on third-party services fail,
 * such as API outages, network issues, or invalid responses from external systems.
 *
 * @param {unknown} error - The error to check
 * @returns {boolean} True if the error is a CertusAdiValtError with SRV_EXTERNAL_SERVICE error code
 *
 * @example
 * ```typescript
 * // In payment processing
 * try {
 *   await paymentGateway.charge(amount, paymentMethod);
 * } catch (error) {
 *   if (isExternalServiceError(error)) {
 *     // Implement circuit breaker or fallback payment method
 *     if (circuitBreaker.isOpen('payment_gateway')) {
 *       return useBackupPaymentProvider();
 *     }
 *     // Log external service failures for monitoring
 *     monitoring.logExternalServiceFailure('payment_gateway', error);
 *   }
 *   throw error;
 * }
 *
 * // In dependency health monitoring
 * if (isExternalServiceError(error)) {
 *   dependencyHealth.setStatus('external_api', 'degraded');
 *   alertIfCriticalDependency(error);
 * }
 * ```
 */
export function isExternalServiceError(error: unknown): boolean {
  return isCertusError(error) && error.code === 'SRV_EXTERNAL_SERVICE';
}
import { ErrorCodes, HttpStatus } from '@/constants';
import { CertusErrorOptions } from '@/types';
import {
  CertusAdiValtError,
  CertusAuthenticationError,
  CertusClientError,
  CertusNotFoundError,
  CertusServerError,
  CertusValidationError,
} from '../errors';
import { isCertusError, isClientError, isServerError } from '../guards';

/**
 * Creates a generic CertusAdiValtError with full customization options.
 *
 * This factory function provides a flexible way to create CertusAdiValtError instances
 * with complete control over all error properties. Useful for creating custom error
 * types not covered by the specific error classes.
 *
 * @param {string} message - Human-readable error description
 * @param {CertusErrorOptions} options - Error configuration options
 * @returns {CertusAdiValtError} New CertusAdiValtError instance
 *
 * @example
 * ```typescript
 * // Create a custom business error
 * const error = createCertusError(
 *   'Inventory allocation failed',
 *   {
 *     code: 'INVENTORY_ALLOCATION_FAILED',
 *     statusCode: 409,
 *     context: { productId: 'prod_123', requestedQty: 10, availableQty: 5 },
 *     originalError: allocationError
 *   }
 * );
 *
 * // Create error with minimal options
 * const error = createCertusError('Operation failed', {
 *   code: ErrorCodes.GEN_BAD_REQUEST,
 *   statusCode: HttpStatus.BAD_REQUEST
 * });
 * ```
 */
export function createCertusError(
  message: string,
  options: CertusErrorOptions
): CertusAdiValtError {
  return new CertusAdiValtError(
    message,
    options.code,
    options.statusCode,
    options.context,
    options.originalError
  );
}

/**
 * Creates a validation error for input or data validation failures.
 *
 * Convenience factory for creating CertusValidationError instances with
 * consistent error code (VAL_INVALID_INPUT) and status code (422 Unprocessable Entity).
 *
 * @param {string} [message='Validation failed'] - Human-readable error description
 * @param {Record<string, unknown>} [context] - Additional context about validation failures
 * @returns {CertusValidationError} New CertusValidationError instance
 *
 * @example
 * ```typescript
 * // Basic validation error
 * throw createValidationError('Email format is invalid');
 *
 * // Validation error with detailed context
 * throw createValidationError(
 *   'User profile validation failed',
 *   {
 *     validationErrors: [
 *       { field: 'age', issue: 'Must be at least 18', value: 16 },
 *       { field: 'email', issue: 'Already registered', value: 'user@example.com' }
 *     ],
 *     totalErrors: 2
 *   }
 * );
 *
 * // In schema validation
 * const result = userSchema.validate(data);
 * if (result.error) {
 *   throw createValidationError('Schema validation failed', {
 *     schemaErrors: result.error.details,
 *     receivedData: data
 *   });
 * }
 * ```
 */
export function createValidationError(
  message: string = 'Validation failed',
  context?: Record<string, unknown>
): CertusValidationError {
  return new CertusValidationError(message, context);
}

/**
 * Creates a not found error for missing resources or entities.
 *
 * Convenience factory for creating CertusNotFoundError instances with
 * consistent error code (GEN_NOT_FOUND) and status code (404 Not Found).
 *
 * @param {string} [message='Resource not found'] - Human-readable error description
 * @param {Record<string, unknown>} [context] - Additional context about the missing resource
 * @returns {CertusNotFoundError} New CertusNotFoundError instance
 *
 * @example
 * ```typescript
 * // Basic not found error
 * throw createNotFoundError('User not found');
 *
 * // Not found error with resource details
 * throw createNotFoundError(
 *   `Order ${orderId} not found`,
 *   {
 *     resourceType: 'Order',
 *     resourceId: orderId,
 *     searchedBy: 'id',
 *     availableResources: ['users', 'products', 'categories']
 *   }
 * );
 *
 * // In repository pattern
 * const user = await userRepository.findById(userId);
 * if (!user) {
 *   throw createNotFoundError(`User with ID ${userId} not found`, {
 *     repository: 'UserRepository',
 *     method: 'findById',
 *     criteria: { id: userId }
 *   });
 * }
 * ```
 */
export function createNotFoundError(
  message: string = 'Resource not found',
  context?: Record<string, unknown>
): CertusNotFoundError {
  return new CertusNotFoundError(message, context);
}

/**
 * Creates an authentication error for credential or token failures.
 *
 * Convenience factory for creating CertusAuthenticationError instances with
 * consistent error code (AUTH_INVALID_CREDENTIALS) and status code (401 Unauthorized).
 *
 * @param {string} [message='Authentication failed'] - Human-readable error description
 * @param {Record<string, unknown>} [context] - Additional context about authentication failure
 * @returns {CertusAuthenticationError} New CertusAuthenticationError instance
 *
 * @example
 * ```typescript
 * // Basic authentication error
 * throw createAuthenticationError('Invalid credentials');
 *
 * // Authentication error with security context
 * throw createAuthenticationError(
 *   'Token validation failed',
 *   {
 *     tokenType: 'access_token',
 *     reason: 'signature_invalid',
 *     issuedAt: '2024-01-01T00:00:00Z',
 *     clientIp: '192.168.1.100'
 *   }
 * );
 *
 * // In authentication middleware
 * if (!isValidToken(authToken)) {
 *   throw createAuthenticationError('Invalid or expired token', {
 *     token: maskSensitiveData(authToken),
 *     validationMethod: 'jwt_verify'
 *   });
 * }
 * ```
 */
export function createAuthenticationError(
  message: string = 'Authentication failed',
  context?: Record<string, unknown>
): CertusAuthenticationError {
  return new CertusAuthenticationError(
    message,
    ErrorCodes.AUTH_INVALID_CREDENTIALS,
    HttpStatus.UNAUTHORIZED,
    context
  );
}

// Error transformation utilities

/**
 * Wraps an unknown error into a CertusAdiValtError, preserving original error information.
 *
 * This utility safely converts any error (including non-Error objects) into a
 * CertusAdiValtError instance. If the input is already a CertusAdiValtError,
 * it returns the original error unchanged.
 *
 * @param {unknown} error - The error to wrap (can be any type)
 * @param {string} [message] - Optional custom error message (uses original message if not provided)
 * @param {string} [code=ErrorCodes.SRV_INTERNAL_ERROR] - Error code for the wrapped error
 * @returns {CertusAdiValtError} CertusAdiValtError instance (original if already a Certus error)
 *
 * @example
 * ```typescript
 * // Wrap a generic Error
 * try {
 *   JSON.parse(invalidJson);
 * } catch (error) {
 *   throw wrapError(error, 'Failed to parse JSON data');
 * }
 *
 * // Wrap non-Error objects
 * const result = someOperation();
 * if (result instanceof Error) {
 *   throw wrapError(result);
 * } else if (!result.success) {
 *   throw wrapError(new Error('Operation failed'), 'Custom error message');
 * }
 *
 * // In async operations with unknown errors
 * try {
 *   await externalService.call();
 * } catch (error) {
 *   // Converts any error to CertusAdiValtError for consistent handling
 *   const wrappedError = wrapError(error, 'External service call failed', 'SRV_EXTERNAL_ERROR');
 *   logger.error(wrappedError.toLog());
 *   throw wrappedError;
 * }
 * ```
 */
export function wrapError(
  error: unknown,
  message?: string,
  code: string = ErrorCodes.SRV_INTERNAL_ERROR
): CertusAdiValtError {
  if (isCertusError(error)) {
    return error;
  }

  const errorMessage = message || (error instanceof Error ? error.message : 'An error occurred');

  return new CertusAdiValtError(
    errorMessage,
    code,
    HttpStatus.INTERNAL_SERVER_ERROR,
    {},
    error instanceof Error ? error : undefined
  );
}

/**
 * Converts an unknown error to a client error (4xx status code).
 *
 * This utility ensures that any error is converted to a CertusClientError instance.
 * If the input is already a client error, it returns the original error unchanged.
 * Useful for ensuring client-facing errors have appropriate status codes.
 *
 * @param {unknown} error - The error to convert
 * @returns {CertusClientError} CertusClientError instance
 *
 * @example
 * ```typescript
 * // In API route handling
 * try {
 *   await processUserRequest(request.body);
 * } catch (error) {
 *   // Ensure all errors returned to client are client errors
 *   const clientError = toClientError(error);
 *   return res.status(clientError.statusCode).json(clientError.toJSON());
 * }
 *
 * // In form validation
 * const validationResult = validateFormData(formData);
 * if (!validationResult.valid) {
 *   throw toClientError(validationResult.error);
 * }
 *
 * // Convert third-party library errors to client errors
 * try {
 *   await emailService.send(email);
 * } catch (error) {
 *   // Convert service-specific errors to generic client errors
 *   throw toClientError(error).withContext({ service: 'email', template: 'welcome' });
 * }
 * ```
 */
export function toClientError(error: unknown): CertusClientError {
  if (isCertusError(error) && isClientError(error)) {
    return error as CertusClientError;
  }

  return new CertusClientError(
    error instanceof Error ? error.message : 'Client error occurred',
    ErrorCodes.GEN_BAD_REQUEST,
    HttpStatus.BAD_REQUEST,
    { originalError: error }
  );
}

/**
 * Converts an unknown error to a server error (5xx status code).
 *
 * This utility ensures that any error is converted to a CertusServerError instance.
 * If the input is already a server error, it returns the original error unchanged.
 * Useful for ensuring server-side errors are properly categorized.
 *
 * @param {unknown} error - The error to convert
 * @returns {CertusServerError} CertusServerError instance
 *
 * @example
 * ```typescript
 * // In background job processing
 * try {
 *   await processBackgroundJob(jobData);
 * } catch (error) {
 *   // Ensure all background job errors are server errors
 *   const serverError = toServerError(error);
 *   logger.error('Background job failed:', serverError.toLog());
 *   metrics.increment('background_job_errors');
 *   throw serverError;
 * }
 *
 * // In database operations
 * try {
 *   await database.transaction(async (tx) => {
 *     await tx.insert(users).values(userData);
 *   });
 * } catch (error) {
 *   // Convert database errors to server errors
 *   throw toServerError(error).withContext({ operation: 'user_creation', transaction: true });
 * }
 *
 * // In health check endpoints
 * try {
 *   await checkSystemHealth();
 * } catch (error) {
 *   // Health check failures are server errors
 *   const healthError = toServerError(error);
 *   healthStatus.overall = 'unhealthy';
 *   throw healthError;
 * }
 * ```
 */
export function toServerError(error: unknown): CertusServerError {
  if (isCertusError(error) && isServerError(error)) {
    return error as CertusServerError;
  }

  return new CertusServerError(
    error instanceof Error ? error.message : 'Server error occurred',
    ErrorCodes.SRV_INTERNAL_ERROR,
    HttpStatus.INTERNAL_SERVER_ERROR,
    { originalError: error }
  );
}

// Error assertion utilities

/**
 * Asserts that an unknown value is a CertusAdiValtError instance.
 *
 * This assertion function throws an error if the input is not a CertusAdiValtError,
 * providing runtime type safety and ensuring error handling consistency.
 *
 * @param {unknown} error - The value to assert as CertusAdiValtError
 * @param {string} [message] - Custom error message for assertion failure
 * @throws {CertusServerError} Throws if the value is not a CertusAdiValtError
 *
 * @example
 * ```typescript
 * // In error processing functions
 * function processError(error: unknown) {
 *   assertCertusError(error, 'Expected a Certus error for processing');
 *
 *   // TypeScript now knows error is CertusAdiValtError
 *   console.log(error.code); // Safe access
 *   return error.toJSON();
 * }
 *
 * // In test assertions
 * it('should throw Certus error', async () => {
 *   await expect(asyncOperation()).rejects.toThrow();
 *   try {
 *     await asyncOperation();
 *   } catch (error) {
 *     assertCertusError(error);
 *     expect(error.code).toBe('VALIDATION_ERROR');
 *   }
 * });
 *
 * // In error transformation pipelines
 * const processedErrors = rawErrors.map(error => {
 *   assertCertusError(error);
 *   return error.withContext({ processedAt: new Date() });
 * });
 * ```
 */
export function assertCertusError(
  error: unknown,
  message?: string
): asserts error is CertusAdiValtError {
  if (!isCertusError(error)) {
    throw new CertusServerError(
      message || 'Expected CertusAdiValtError instance',
      ErrorCodes.SRV_INTERNAL_ERROR,
      HttpStatus.INTERNAL_SERVER_ERROR,
      { actualError: error }
    );
  }
}

/**
 * Asserts that an unknown value is a client error (4xx status code).
 *
 * This assertion function throws an error if the input is not a CertusClientError,
 * providing runtime validation for client error handling scenarios.
 *
 * @param {unknown} error - The value to assert as CertusClientError
 * @param {string} [message] - Custom error message for assertion failure
 * @throws {CertusServerError} Throws if the value is not a CertusClientError
 *
 * @example
 * ```typescript
 * // In API response formatting
 * function formatClientErrorResponse(error: unknown) {
 *   assertClientError(error, 'Expected client error for response formatting');
 *
 *   // TypeScript now knows error is CertusClientError
 *   return {
 *     status: error.statusCode,
 *     code: error.code,
 *     message: error.message
 *   };
 * }
 *
 * // In client-side error handling
 * function handleClientError(error: unknown) {
 *   assertClientError(error);
 *
 *   // Safe to use client error specific properties
 *   if (error.statusCode === 404) {
 *     showNotFoundMessage(error.message);
 *   } else if (error.statusCode === 422) {
 *     showValidationErrors(error.context);
 *   }
 * }
 *
 * // In middleware error filtering
 * const clientErrors = allErrors.filter(error => {
 *   try {
 *     assertClientError(error);
 *     return true;
 *   } catch {
 *     return false;
 *   }
 * });
 * ```
 */
export function assertClientError(
  error: unknown,
  message?: string
): asserts error is CertusClientError {
  assertCertusError(error, message);
  if (!isClientError(error)) {
    throw new CertusServerError(
      message || 'Expected client error',
      ErrorCodes.SRV_INTERNAL_ERROR,
      HttpStatus.INTERNAL_SERVER_ERROR,
      { actualError: error }
    );
  }
}
/**
 * Comprehensive error code constants for the CertusAdiValt system.
 *
 * Organized by domain/category with consistent naming conventions.
 * Each error code represents a specific error scenario that can occur
 * throughout the application, enabling consistent error handling and monitoring.
 *
 * @namespace ErrorCodes
 *
 * @example
 * ```typescript
 * // Using error codes in error creation
 * throw new CertusAuthenticationError(
 *   'Invalid credentials',
 *   ErrorCodes.AUTH_INVALID_CREDENTIALS,
 *   HttpStatus.UNAUTHORIZED
 * );
 *
 * // Error code type checking
 * function handleError(code: ErrorCodeType) {
 *   if (code.startsWith('AUTH_')) {
 *     // Handle authentication errors
 *   } else if (code.startsWith('VAL_')) {
 *     // Handle validation errors
 *   }
 * }
 * ```
 */
export const ErrorCodes = {
  // Authentication & Authorization (AUTH_*)

  /**
   * Invalid username, password, or credentials provided
   */
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',

  /**
   * Authentication token has expired and is no longer valid
   */
  AUTH_TOKEN_EXPIRED: 'AUTH_TOKEN_EXPIRED',

  /**
   * Authentication token is malformed or cannot be verified
   */
  AUTH_INVALID_TOKEN: 'AUTH_INVALID_TOKEN',

  /**
   * Authentication token is required but not provided
   */
  AUTH_TOKEN_REQUIRED: 'AUTH_TOKEN_REQUIRED',

  /**
   * User lacks required permissions for the requested operation
   */
  AUTH_INSUFFICIENT_PERMISSIONS: 'AUTH_INSUFFICIENT_PERMISSIONS',

  /**
   * User session has expired due to inactivity
   */
  AUTH_SESSION_EXPIRED: 'AUTH_SESSION_EXPIRED',

  /**
   * User session has been manually revoked or terminated
   */
  AUTH_SESSION_REVOKED: 'AUTH_SESSION_REVOKED',

  /**
   * Referenced session cannot be found in the system
   */
  AUTH_SESSION_NOT_FOUND: 'AUTH_SESSION_NOT_FOUND',

  /**
   * Generic unauthorized access attempt
   */
  AUTH_UNAUTHORIZED: 'AUTH_UNAUTHORIZED',

  /**
   * Account temporarily locked due to security policies
   */
  AUTH_ACCOUNT_LOCKED: 'AUTH_ACCOUNT_LOCKED',

  /**
   * Account has been permanently disabled
   */
  AUTH_ACCOUNT_DISABLED: 'AUTH_ACCOUNT_DISABLED',

  /**
   * Account awaiting activation or approval
   */
  AUTH_ACCOUNT_PENDING: 'AUTH_ACCOUNT_PENDING',

  /**
   * Password reset required before accessing the system
   */
  AUTH_PASSWORD_RESET_REQUIRED: 'AUTH_PASSWORD_RESET_REQUIRED',

  /**
   * Multi-factor authentication required for this operation
   */
  AUTH_MFA_REQUIRED: 'AUTH_MFA_REQUIRED',

  /**
   * Invalid or expired multi-factor authentication code
   */
  AUTH_MFA_INVALID: 'AUTH_MFA_INVALID',

  /**
   * OAuth authentication flow failed
   */
  AUTH_OAUTH_ERROR: 'AUTH_OAUTH_ERROR',

  /**
   * Authentication provider encountered an error
   */
  AUTH_PROVIDER_ERROR: 'AUTH_PROVIDER_ERROR',

  /**
   * Refresh token has expired and cannot be used
   */
  AUTH_REFRESH_TOKEN_EXPIRED: 'AUTH_REFRESH_TOKEN_EXPIRED',

  /**
   * Refresh token is invalid or has been revoked
   */
  AUTH_REFRESH_TOKEN_INVALID: 'AUTH_REFRESH_TOKEN_INVALID',

  /**
   * Email address verification required
   */
  AUTH_EMAIL_NOT_VERIFIED: 'AUTH_EMAIL_NOT_VERIFIED',

  /**
   * Phone number verification required
   */
  AUTH_PHONE_NOT_VERIFIED: 'AUTH_PHONE_NOT_VERIFIED',

  /**
   * Too many authentication attempts from this source
   */
  AUTH_RATE_LIMIT_EXCEEDED: 'AUTH_RATE_LIMIT_EXCEEDED',

  // Validation (VAL_*)

  /**
   * General input validation failure
   */
  VAL_INVALID_INPUT: 'VAL_INVALID_INPUT',

  /**
   * Data does not conform to expected schema
   */
  VAL_SCHEMA_ERROR: 'VAL_SCHEMA_ERROR',

  /**
   * Business rule or domain constraint violation
   */
  VAL_BUSINESS_RULE: 'VAL_BUSINESS_RULE',

  /**
   * Required field is missing or empty
   */
  VAL_REQUIRED_FIELD: 'VAL_REQUIRED_FIELD',

  /**
   * Data format does not match expected pattern
   */
  VAL_INVALID_FORMAT: 'VAL_INVALID_FORMAT',

  /**
   * Email address format is invalid
   */
  VAL_INVALID_EMAIL: 'VAL_INVALID_EMAIL',

  /**
   * Phone number format is invalid
   */
  VAL_INVALID_PHONE: 'VAL_INVALID_PHONE',

  /**
   * Date format or value is invalid
   */
  VAL_INVALID_DATE: 'VAL_INVALID_DATE',

  /**
   * URL format is invalid
   */
  VAL_INVALID_URL: 'VAL_INVALID_URL',

  /**
   * UUID format is invalid
   */
  VAL_INVALID_UUID: 'VAL_INVALID_UUID',

  /**
   * String value is shorter than minimum allowed length
   */
  VAL_STRING_TOO_SHORT: 'VAL_STRING_TOO_SHORT',

  /**
   * String value exceeds maximum allowed length
   */
  VAL_STRING_TOO_LONG: 'VAL_STRING_TOO_LONG',

  /**
   * Numeric value is below minimum allowed value
   */
  VAL_NUMBER_TOO_SMALL: 'VAL_NUMBER_TOO_SMALL',

  /**
   * Numeric value exceeds maximum allowed value
   */
  VAL_NUMBER_TOO_LARGE: 'VAL_NUMBER_TOO_LARGE',

  /**
   * Array has fewer items than minimum required
   */
  VAL_ARRAY_TOO_SHORT: 'VAL_ARRAY_TOO_SHORT',

  /**
   * Array has more items than maximum allowed
   */
  VAL_ARRAY_TOO_LONG: 'VAL_ARRAY_TOO_LONG',

  /**
   * Value is not among the allowed choices
   */
  VAL_INVALID_CHOICE: 'VAL_INVALID_CHOICE',

  /**
   * Value violates unique constraint
   */
  VAL_UNIQUE_CONSTRAINT: 'VAL_UNIQUE_CONSTRAINT',

  /**
   * Value violates foreign key constraint
   */
  VAL_FOREIGN_KEY_CONSTRAINT: 'VAL_FOREIGN_KEY_CONSTRAINT',

  // Database (DB_*)

  /**
   * Cannot establish connection to database
   */
  DB_CONNECTION_ERROR: 'DB_CONNECTION_ERROR',

  /**
   * Database unique constraint violation
   */
  DB_UNIQUE_CONSTRAINT: 'DB_UNIQUE_CONSTRAINT',

  /**
   * Database foreign key constraint violation
   */
  DB_FOREIGN_KEY_CONSTRAINT: 'DB_FOREIGN_KEY_CONSTRAINT',

  /**
   * Database operation timed out
   */
  DB_TIMEOUT_ERROR: 'DB_TIMEOUT_ERROR',

  /**
   * Database query execution failed
   */
  DB_QUERY_ERROR: 'DB_QUERY_ERROR',

  /**
   * Database transaction failed
   */
  DB_TRANSACTION_ERROR: 'DB_TRANSACTION_ERROR',

  /**
   * Requested record not found in database
   */
  DB_RECORD_NOT_FOUND: 'DB_RECORD_NOT_FOUND',

  /**
   * Attempt to create duplicate database entry
   */
  DB_DUPLICATE_ENTRY: 'DB_DUPLICATE_ENTRY',

  /**
   * Database deadlock detected
   */
  DB_DEADLOCK_ERROR: 'DB_DEADLOCK_ERROR',

  /**
   * Database connection limit reached
   */
  DB_CONNECTION_LIMIT: 'DB_CONNECTION_LIMIT',

  /**
   * Database migration script failed
   */
  DB_MIGRATION_ERROR: 'DB_MIGRATION_ERROR',

  /**
   * Database backup operation failed
   */
  DB_BACKUP_ERROR: 'DB_BACKUP_ERROR',

  // File & Storage (FILE_*)

  /**
   * File upload operation failed
   */
  FILE_UPLOAD_ERROR: 'FILE_UPLOAD_ERROR',

  /**
   * File download operation failed
   */
  FILE_DOWNLOAD_ERROR: 'FILE_DOWNLOAD_ERROR',

  /**
   * File deletion operation failed
   */
  FILE_DELETE_ERROR: 'FILE_DELETE_ERROR',

  /**
   * Requested file not found in storage
   */
  FILE_NOT_FOUND: 'FILE_NOT_FOUND',

  /**
   * File size exceeds allowed limit
   */
  FILE_TOO_LARGE: 'FILE_TOO_LARGE',

  /**
   * File type is not allowed
   */
  FILE_INVALID_TYPE: 'FILE_INVALID_TYPE',

  /**
   * File name contains invalid characters or format
   */
  FILE_INVALID_NAME: 'FILE_INVALID_NAME',

  /**
   * Storage quota or limit exceeded
   */
  FILE_STORAGE_LIMIT: 'FILE_STORAGE_LIMIT',

  /**
   * File is corrupted or cannot be read
   */
  FILE_CORRUPTED: 'FILE_CORRUPTED',

  /**
   * Insufficient permissions to access the file
   */
  FILE_PERMISSION_DENIED: 'FILE_PERMISSION_DENIED',

  // Server & Infrastructure (SRV_*)

  /**
   * Generic internal server error
   */
  SRV_INTERNAL_ERROR: 'SRV_INTERNAL_ERROR',

  /**
   * External service or API call failed
   */
  SRV_EXTERNAL_SERVICE: 'SRV_EXTERNAL_SERVICE',

  /**
   * Server configuration error or misconfiguration
   */
  SRV_CONFIGURATION_ERROR: 'SRV_CONFIGURATION_ERROR',

  /**
   * Data encryption operation failed
   */
  SRV_ENCRYPTION_ERROR: 'SRV_ENCRYPTION_ERROR',

  /**
   * Data decryption operation failed
   */
  SRV_DECRYPTION_ERROR: 'SRV_DECRYPTION_ERROR',

  /**
   * Rate limit exceeded for server operation
   */
  SRV_RATE_LIMIT: 'SRV_RATE_LIMIT',

  /**
   * Server is in maintenance mode
   */
  SRV_MAINTENANCE_MODE: 'SRV_MAINTENANCE_MODE',

  /**
   * Server service temporarily unavailable
   */
  SRV_SERVICE_UNAVAILABLE: 'SRV_SERVICE_UNAVAILABLE',

  /**
   * Server memory limit exceeded
   */
  SRV_MEMORY_LIMIT: 'SRV_MEMORY_LIMIT',

  /**
   * Server CPU limit exceeded
   */
  SRV_CPU_LIMIT: 'SRV_CPU_LIMIT',

  /**
   * Server disk space limit exceeded
   */
  SRV_DISK_SPACE: 'SRV_DISK_SPACE',

  // Network & Communication (NET_*)

  /**
   * Generic network communication error
   */
  NET_NETWORK_ERROR: 'NET_NETWORK_ERROR',

  /**
   * Network connection timeout
   */
  NET_CONNECTION_TIMEOUT: 'NET_CONNECTION_TIMEOUT',

  /**
   * DNS resolution failed
   */
  NET_DNS_ERROR: 'NET_DNS_ERROR',

  /**
   * SSL/TLS handshake or certificate error
   */
  NET_SSL_ERROR: 'NET_SSL_ERROR',

  /**
   * Proxy server connection or configuration error
   */
  NET_PROXY_ERROR: 'NET_PROXY_ERROR',

  /**
   * Request blocked by firewall or security policy
   */
  NET_FIREWALL_BLOCKED: 'NET_FIREWALL_BLOCKED',

  // Payment & Billing (PAY_*)

  /**
   * Payment processing failed
   */
  PAY_PAYMENT_FAILED: 'PAY_PAYMENT_FAILED',

  /**
   * Insufficient funds for payment
   */
  PAY_INSUFFICIENT_FUNDS: 'PAY_INSUFFICIENT_FUNDS',

  /**
   * Card was declined by issuer
   */
  PAY_CARD_DECLINED: 'PAY_CARD_DECLINED',

  /**
   * Invalid card details provided
   */
  PAY_INVALID_CARD: 'PAY_INVALID_CARD',

  /**
   * Card has expired
   */
  PAY_EXPIRED_CARD: 'PAY_EXPIRED_CARD',

  /**
   * Payment processor encountered an error
   */
  PAY_PROCESSOR_ERROR: 'PAY_PROCESSOR_ERROR',

  /**
   * Refund operation failed
   */
  PAY_REFUND_FAILED: 'PAY_REFUND_FAILED',

  /**
   * Subscription has expired
   */
  PAY_SUBSCRIPTION_EXPIRED: 'PAY_SUBSCRIPTION_EXPIRED',

  /**
   * Requested invoice not found
   */
  PAY_INVOICE_NOT_FOUND: 'PAY_INVOICE_NOT_FOUND',

  // Notification & Email (NOTIF_*)

  /**
   * Email delivery failed
   */
  NOTIF_EMAIL_FAILED: 'NOTIF_EMAIL_FAILED',

  /**
   * SMS delivery failed
   */
  NOTIF_SMS_FAILED: 'NOTIF_SMS_FAILED',

  /**
   * Push notification delivery failed
   */
  NOTIF_PUSH_FAILED: 'NOTIF_PUSH_FAILED',

  /**
   * Notification template not found
   */
  NOTIF_TEMPLATE_NOT_FOUND: 'NOTIF_TEMPLATE_NOT_FOUND',

  /**
   * Notification rate limit exceeded
   */
  NOTIF_RATE_LIMIT: 'NOTIF_RATE_LIMIT',

  /**
   * Notification provider error
   */
  NOTIF_PROVIDER_ERROR: 'NOTIF_PROVIDER_ERROR',

  // Generic (GEN_*)

  /**
   * Generic validation error
   */
  GEN_VALIDATION_ERROR: 'GEN_VALIDATION_ERROR',

  /**
   * Generic resource not found error
   */
  GEN_NOT_FOUND: 'GEN_NOT_FOUND',

  /**
   * Generic timeout error
   */
  GEN_TIMEOUT: 'GEN_TIMEOUT',

  /**
   * Generic network error
   */
  GEN_NETWORK_ERROR: 'GEN_NETWORK_ERROR',

  /**
   * Generic service error
   */
  GEN_SERVICE_ERROR: 'GEN_SERVICE_ERROR',

  /**
   * Unknown or unclassified error
   */
  GEN_UNKNOWN_ERROR: 'GEN_UNKNOWN_ERROR',

  /**
   * Generic forbidden access error
   */
  GEN_FORBIDDEN: 'GEN_FORBIDDEN',

  /**
   * Generic unauthorized access error
   */
  GEN_UNAUTHORIZED: 'GEN_UNAUTHORIZED',

  /**
   * Generic bad request error
   */
  GEN_BAD_REQUEST: 'GEN_BAD_REQUEST',

  /**
   * Generic conflict error
   */
  GEN_CONFLICT: 'GEN_CONFLICT',
} as const;

/**
 * Union type of all possible error codes in the system.
 *
 * Enables type-safe usage of error codes throughout the application
 * and provides autocomplete support in IDEs.
 *
 * @example
 * ```typescript
 * function handleError(code: ErrorCodeType) {
 *   switch (code) {
 *     case ErrorCodes.AUTH_INVALID_CREDENTIALS:
 *       // Handle invalid credentials
 *       break;
 *     case ErrorCodes.VAL_INVALID_EMAIL:
 *       // Handle invalid email
 *       break;
 *     default:
 *       // Handle other error codes
 *   }
 * }
 *
 * // Type-safe error code assignment
 * const errorCode: ErrorCodeType = ErrorCodes.DB_CONNECTION_ERROR;
 * ```
 */
export type ErrorCodeType = (typeof ErrorCodes)[keyof typeof ErrorCodes];
/**
 * Comprehensive HTTP status code constants for the CertusAdiValt system.
 *
 * Provides all standard HTTP status codes as named constants for type-safe usage
 * throughout the application. Organized by HTTP status code categories (1xx-5xx).
 *
 * @namespace HttpStatus
 *
 * @example
 * ```typescript
 * // Using HTTP status codes in API responses
 * return response.status(HttpStatus.OK).json({ data: result });
 *
 * // Using in error creation
 * throw new CertusNotFoundError(
 *   'User not found',
 *   ErrorCodes.GEN_NOT_FOUND,
 *   HttpStatus.NOT_FOUND
 * );
 *
 * // Type-safe status code handling
 * function handleResponse(status: HttpStatusType) {
 *   if (status >= 200 && status < 300) {
 *     // Handle success responses
 *   } else if (status >= 400 && status < 500) {
 *     // Handle client errors
 *   }
 * }
 * ```
 */
export const HttpStatus = {
  // Informational (1xx)

  /**
   * 100 Continue
   * The server has received the request headers and the client should proceed to send the request body.
   */
  CONTINUE: 100,

  /**
   * 101 Switching Protocols
   * The requester has asked the server to switch protocols and the server has agreed to do so.
   */
  SWITCHING_PROTOCOLS: 101,

  /**
   * 102 Processing (WebDAV)
   * The server has received and is processing the request, but no response is available yet.
   */
  PROCESSING: 102,

  /**
   * 103 Early Hints
   * Used to return some response headers before final HTTP message.
   */
  EARLY_HINTS: 103,

  // Success (2xx)

  /**
   * 200 OK
   * The request has succeeded.
   */
  OK: 200,

  /**
   * 201 Created
   * The request has been fulfilled and resulted in a new resource being created.
   */
  CREATED: 201,

  /**
   * 202 Accepted
   * The request has been accepted for processing, but the processing has not been completed.
   */
  ACCEPTED: 202,

  /**
   * 203 Non-Authoritative Information
   * The server is a transforming proxy that received a 200 OK from its origin.
   */
  NON_AUTHORITATIVE_INFORMATION: 203,

  /**
   * 204 No Content
   * The server successfully processed the request and is not returning any content.
   */
  NO_CONTENT: 204,

  /**
   * 205 Reset Content
   * The server successfully processed the request, but is not returning any content and requires the requester to reset the document view.
   */
  RESET_CONTENT: 205,

  /**
   * 206 Partial Content
   * The server is delivering only part of the resource due to a range header sent by the client.
   */
  PARTIAL_CONTENT: 206,

  /**
   * 207 Multi-Status (WebDAV)
   * The message body that follows is an XML message and can contain a number of separate response codes.
   */
  MULTI_STATUS: 207,

  /**
   * 208 Already Reported (WebDAV)
   * The members of a DAV binding have already been enumerated in a previous reply to this request.
   */
  ALREADY_REPORTED: 208,

  /**
   * 226 IM Used
   * The server has fulfilled a request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.
   */
  IM_USED: 226,

  // Redirection (3xx)

  /**
   * 300 Multiple Choices
   * The request has more than one possible response and the user should choose one.
   */
  MULTIPLE_CHOICES: 300,

  /**
   * 301 Moved Permanently
   * The URL of the requested resource has been changed permanently.
   */
  MOVED_PERMANENTLY: 301,

  /**
   * 302 Found
   * The URI of requested resource has been changed temporarily.
   */
  FOUND: 302,

  /**
   * 303 See Other
   * The server sent this response to direct the client to get the requested resource at another URI with a GET request.
   */
  SEE_OTHER: 303,

  /**
   * 304 Not Modified
   * Used for caching purposes. The client can continue to use the same cached version of the response.
   */
  NOT_MODIFIED: 304,

  /**
   * 305 Use Proxy
   * The requested resource is available only through a proxy, the address for which is provided in the response.
   */
  USE_PROXY: 305,

  /**
   * 307 Temporary Redirect
   * The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request.
   */
  TEMPORARY_REDIRECT: 307,

  /**
   * 308 Permanent Redirect
   * This means that the resource is now permanently located at another URI.
   */
  PERMANENT_REDIRECT: 308,

  // Client errors (4xx)

  /**
   * 400 Bad Request
   * The server cannot or will not process the request due to an apparent client error.
   */
  BAD_REQUEST: 400,

  /**
   * 401 Unauthorized
   * The request has not been applied because it lacks valid authentication credentials for the target resource.
   */
  UNAUTHORIZED: 401,

  /**
   * 402 Payment Required
   * Reserved for future use. The original intention was that this code might be used as part of some form of digital cash or micropayment scheme.
   */
  PAYMENT_REQUIRED: 402,

  /**
   * 403 Forbidden
   * The server understood the request but refuses to authorize it.
   */
  FORBIDDEN: 403,

  /**
   * 404 Not Found
   * The server cannot find the requested resource.
   */
  NOT_FOUND: 404,

  /**
   * 405 Method Not Allowed
   * The request method is known by the server but has been disabled and cannot be used.
   */
  METHOD_NOT_ALLOWED: 405,

  /**
   * 406 Not Acceptable
   * The server cannot produce a response matching the list of acceptable values defined in the request's proactive content negotiation headers.
   */
  NOT_ACCEPTABLE: 406,

  /**
   * 407 Proxy Authentication Required
   * The client must first authenticate itself with the proxy.
   */
  PROXY_AUTHENTICATION_REQUIRED: 407,

  /**
   * 408 Request Timeout
   * The server would like to shut down this unused connection.
   */
  REQUEST_TIMEOUT: 408,

  /**
   * 409 Conflict
   * The request could not be completed due to a conflict with the current state of the target resource.
   */
  CONFLICT: 409,

  /**
   * 410 Gone
   * The target resource is no longer available at the origin server and this condition is likely to be permanent.
   */
  GONE: 410,

  /**
   * 411 Length Required
   * The server refuses to accept the request without a defined Content-Length.
   */
  LENGTH_REQUIRED: 411,

  /**
   * 412 Precondition Failed
   * One or more conditions given in the request header fields evaluated to false when tested on the server.
   */
  PRECONDITION_FAILED: 412,

  /**
   * 413 Payload Too Large
   * The server is refusing to process a request because the request payload is larger than the server is willing or able to process.
   */
  PAYLOAD_TOO_LARGE: 413,

  /**
   * 414 URI Too Long
   * The server is refusing to service the request because the request-target is longer than the server is willing to interpret.
   */
  URI_TOO_LONG: 414,

  /**
   * 415 Unsupported Media Type
   * The server is refusing to service the request because the entity of the request is in a format not supported by the target resource for the requested method.
   */
  UNSUPPORTED_MEDIA_TYPE: 415,

  /**
   * 416 Range Not Satisfiable
   * The range specified by the Range header field in the request cannot be fulfilled.
   */
  RANGE_NOT_SATISFIABLE: 416,

  /**
   * 417 Expectation Failed
   * The expectation given in the request's Expect header field could not be met by at least one of the inbound servers.
   */
  EXPECTATION_FAILED: 417,

  /**
   * 418 I'm a teapot (RFC 2324)
   * The server refuses the attempt to brew coffee with a teapot.
   */
  IM_A_TEAPOT: 418,

  /**
   * 421 Misdirected Request
   * The request was directed at a server that is not able to produce a response.
   */
  MISDIRECTED_REQUEST: 421,

  /**
   * 422 Unprocessable Entity (WebDAV)
   * The request was well-formed but was unable to be followed due to semantic errors.
   */
  UNPROCESSABLE_ENTITY: 422,

  /**
   * 423 Locked (WebDAV)
   * The resource that is being accessed is locked.
   */
  LOCKED: 423,

  /**
   * 424 Failed Dependency (WebDAV)
   * The request failed due to failure of a previous request.
   */
  FAILED_DEPENDENCY: 424,

  /**
   * 425 Too Early
   * The server is unwilling to risk processing a request that might be replayed.
   */
  TOO_EARLY: 425,

  /**
   * 426 Upgrade Required
   * The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.
   */
  UPGRADE_REQUIRED: 426,

  /**
   * 428 Precondition Required
   * The origin server requires the request to be conditional.
   */
  PRECONDITION_REQUIRED: 428,

  /**
   * 429 Too Many Requests
   * The user has sent too many requests in a given amount of time ("rate limiting").
   */
  TOO_MANY_REQUESTS: 429,

  /**
   * 431 Request Header Fields Too Large
   * The server is unwilling to process the request because its header fields are too large.
   */
  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,

  /**
   * 451 Unavailable For Legal Reasons
   * The server is denying access to the resource as a consequence of a legal demand.
   */
  UNAVAILABLE_FOR_LEGAL_REASONS: 451,

  // Server errors (5xx)

  /**
   * 500 Internal Server Error
   * The server encountered an unexpected condition that prevented it from fulfilling the request.
   */
  INTERNAL_SERVER_ERROR: 500,

  /**
   * 501 Not Implemented
   * The server does not support the functionality required to fulfill the request.
   */
  NOT_IMPLEMENTED: 501,

  /**
   * 502 Bad Gateway
   * The server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.
   */
  BAD_GATEWAY: 502,

  /**
   * 503 Service Unavailable
   * The server is currently unable to handle the request due to temporary overloading or maintenance of the server.
   */
  SERVICE_UNAVAILABLE: 503,

  /**
   * 504 Gateway Timeout
   * The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server.
   */
  GATEWAY_TIMEOUT: 504,

  /**
   * 505 HTTP Version Not Supported
   * The server does not support the HTTP protocol version used in the request.
   */
  HTTP_VERSION_NOT_SUPPORTED: 505,

  /**
   * 506 Variant Also Negotiates
   * The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself.
   */
  VARIANT_ALSO_NEGOTIATES: 506,

  /**
   * 507 Insufficient Storage (WebDAV)
   * The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.
   */
  INSUFFICIENT_STORAGE: 507,

  /**
   * 508 Loop Detected (WebDAV)
   * The server detected an infinite loop while processing the request.
   */
  LOOP_DETECTED: 508,

  /**
   * 510 Not Extended
   * Further extensions to the request are required for the server to fulfill it.
   */
  NOT_EXTENDED: 510,

  /**
   * 511 Network Authentication Required
   * The client needs to authenticate to gain network access.
   */
  NETWORK_AUTHENTICATION_REQUIRED: 511,
} as const;

/**
 * Union type of all possible HTTP status codes in the system.
 *
 * Enables type-safe usage of HTTP status codes throughout the application
 * and provides autocomplete support in IDEs.
 *
 * @example
 * ```typescript
 * function createResponse(status: HttpStatusType, data: any) {
 *   return {
 *     status,
 *     data,
 *     timestamp: new Date().toISOString()
 *   };
 * }
 *
 * // Type-safe status code assignment
 * const successStatus: HttpStatusType = HttpStatus.CREATED;
 * const errorStatus: HttpStatusType = HttpStatus.NOT_FOUND;
 *
 * // Status code range checking
 * function isSuccessStatus(status: HttpStatusType): boolean {
 *   return status >= 200 && status < 300;
 * }
 *
 * function isClientError(status: HttpStatusType): boolean {
 *   return status >= 400 && status < 500;
 * }
 * ```
 */
export type HttpStatusType = (typeof HttpStatus)[keyof typeof HttpStatus];
import { ErrorCodes } from './error-codes';

/**
 * User-friendly error messages mapped to error codes for consistent user communication.
 *
 * Provides human-readable, user-friendly messages for each error code that can be
 * safely displayed to end-users. Messages are designed to be clear, actionable,
 * and avoid exposing sensitive technical details.
 *
 * @namespace ErrorMessages
 *
 * @example
 * ```typescript
 * // Get user-friendly error message
 * const error = new CertusAuthenticationError(
 *   ErrorMessages[ErrorCodes.AUTH_INVALID_CREDENTIALS],
 *   ErrorCodes.AUTH_INVALID_CREDENTIALS,
 *   HttpStatus.UNAUTHORIZED
 * );
 *
 * // Display error to user
 * function showErrorMessage(error: CertusAdiValtError) {
 *   const userMessage = ErrorMessages[error.code] || ErrorMessages[ErrorCodes.GEN_UNKNOWN_ERROR];
 *   displayNotification(userMessage, 'error');
 * }
 *
 * // Internationalization ready
 * function getLocalizedErrorMessage(code: ErrorCodeType, locale: string): string {
 *   const defaultMessage = ErrorMessages[code];
 *   return i18n.t(`errors.${code}`, { defaultValue: defaultMessage, locale });
 * }
 * ```
 */
export const ErrorMessages = {
  // Authentication & Authorization Messages

  /**
   * User-friendly message for invalid credentials
   */
  [ErrorCodes.AUTH_INVALID_CREDENTIALS]: 'Invalid email or password',

  /**
   * User-friendly message for expired authentication tokens
   */
  [ErrorCodes.AUTH_TOKEN_EXPIRED]: 'Authentication token has expired',

  /**
   * User-friendly message for invalid authentication tokens
   */
  [ErrorCodes.AUTH_INVALID_TOKEN]: 'Invalid authentication token',

  /**
   * User-friendly message when authentication token is required but not provided
   */
  [ErrorCodes.AUTH_TOKEN_REQUIRED]: 'Authentication token is required',

  /**
   * User-friendly message for insufficient permissions
   */
  [ErrorCodes.AUTH_INSUFFICIENT_PERMISSIONS]: 'Insufficient permissions to access this resource',

  /**
   * User-friendly message for expired sessions
   */
  [ErrorCodes.AUTH_SESSION_EXPIRED]: 'Session has expired',

  /**
   * User-friendly message for revoked sessions
   */
  [ErrorCodes.AUTH_SESSION_REVOKED]: 'Session has been revoked',

  /**
   * User-friendly message when session is not found
   */
  [ErrorCodes.AUTH_SESSION_NOT_FOUND]: 'Session not found',

  /**
   * User-friendly message for unauthorized access attempts
   */
  [ErrorCodes.AUTH_UNAUTHORIZED]: 'Unauthorized access',

  /**
   * User-friendly message for locked accounts
   */
  [ErrorCodes.AUTH_ACCOUNT_LOCKED]: 'Account has been locked due to multiple failed attempts',

  /**
   * User-friendly message for disabled accounts
   */
  [ErrorCodes.AUTH_ACCOUNT_DISABLED]: 'Account has been disabled',

  /**
   * User-friendly message for pending account activation
   */
  [ErrorCodes.AUTH_ACCOUNT_PENDING]: 'Account is pending activation',

  /**
   * User-friendly message when password reset is required
   */
  [ErrorCodes.AUTH_PASSWORD_RESET_REQUIRED]: 'Password reset required',

  /**
   * User-friendly message when multi-factor authentication is required
   */
  [ErrorCodes.AUTH_MFA_REQUIRED]: 'Multi-factor authentication required',

  /**
   * User-friendly message for invalid MFA codes
   */
  [ErrorCodes.AUTH_MFA_INVALID]: 'Invalid multi-factor authentication code',

  /**
   * User-friendly message for OAuth authentication failures
   */
  [ErrorCodes.AUTH_OAUTH_ERROR]: 'OAuth authentication failed',

  /**
   * User-friendly message for authentication provider errors
   */
  [ErrorCodes.AUTH_PROVIDER_ERROR]: 'Authentication provider error',

  /**
   * User-friendly message for expired refresh tokens
   */
  [ErrorCodes.AUTH_REFRESH_TOKEN_EXPIRED]: 'Refresh token has expired',

  /**
   * User-friendly message for invalid refresh tokens
   */
  [ErrorCodes.AUTH_REFRESH_TOKEN_INVALID]: 'Invalid refresh token',

  /**
   * User-friendly message when email verification is required
   */
  [ErrorCodes.AUTH_EMAIL_NOT_VERIFIED]: 'Email address not verified',

  /**
   * User-friendly message when phone verification is required
   */
  [ErrorCodes.AUTH_PHONE_NOT_VERIFIED]: 'Phone number not verified',

  /**
   * User-friendly message for authentication rate limiting
   */
  [ErrorCodes.AUTH_RATE_LIMIT_EXCEEDED]: 'Too many authentication attempts',

  // Validation Messages

  /**
   * User-friendly message for general invalid input
   */
  [ErrorCodes.VAL_INVALID_INPUT]: 'Invalid input provided',

  /**
   * User-friendly message for schema validation failures
   */
  [ErrorCodes.VAL_SCHEMA_ERROR]: 'Data validation failed',

  /**
   * User-friendly message for business rule violations
   */
  [ErrorCodes.VAL_BUSINESS_RULE]: 'Business rule violation',

  /**
   * User-friendly message for required field validation
   */
  [ErrorCodes.VAL_REQUIRED_FIELD]: 'This field is required',

  /**
   * User-friendly message for invalid format
   */
  [ErrorCodes.VAL_INVALID_FORMAT]: 'Invalid format',

  /**
   * User-friendly message for invalid email addresses
   */
  [ErrorCodes.VAL_INVALID_EMAIL]: 'Invalid email address',

  /**
   * User-friendly message for invalid phone numbers
   */
  [ErrorCodes.VAL_INVALID_PHONE]: 'Invalid phone number',

  /**
   * User-friendly message for invalid date formats
   */
  [ErrorCodes.VAL_INVALID_DATE]: 'Invalid date format',

  /**
   * User-friendly message for invalid URL formats
   */
  [ErrorCodes.VAL_INVALID_URL]: 'Invalid URL format',

  /**
   * User-friendly message for invalid UUID formats
   */
  [ErrorCodes.VAL_INVALID_UUID]: 'Invalid UUID format',

  /**
   * User-friendly message for string length validation (too short)
   */
  [ErrorCodes.VAL_STRING_TOO_SHORT]: 'Text is too short',

  /**
   * User-friendly message for string length validation (too long)
   */
  [ErrorCodes.VAL_STRING_TOO_LONG]: 'Text is too long',

  /**
   * User-friendly message for number range validation (too small)
   */
  [ErrorCodes.VAL_NUMBER_TOO_SMALL]: 'Number is too small',

  /**
   * User-friendly message for number range validation (too large)
   */
  [ErrorCodes.VAL_NUMBER_TOO_LARGE]: 'Number is too large',

  /**
   * User-friendly message for array length validation (too few items)
   */
  [ErrorCodes.VAL_ARRAY_TOO_SHORT]: 'Too few items',

  /**
   * User-friendly message for array length validation (too many items)
   */
  [ErrorCodes.VAL_ARRAY_TOO_LONG]: 'Too many items',

  /**
   * User-friendly message for invalid choice selection
   */
  [ErrorCodes.VAL_INVALID_CHOICE]: 'Invalid selection',

  /**
   * User-friendly message for unique constraint violations
   */
  [ErrorCodes.VAL_UNIQUE_CONSTRAINT]: 'Value must be unique',

  /**
   * User-friendly message for foreign key constraint violations
   */
  [ErrorCodes.VAL_FOREIGN_KEY_CONSTRAINT]: 'Referenced resource not found',

  // Database Messages

  /**
   * User-friendly message for database connection failures
   */
  [ErrorCodes.DB_CONNECTION_ERROR]: 'Database connection failed',

  /**
   * User-friendly message for unique constraint violations
   */
  [ErrorCodes.DB_UNIQUE_CONSTRAINT]: 'Duplicate entry found',

  /**
   * User-friendly message for foreign key constraint violations
   */
  [ErrorCodes.DB_FOREIGN_KEY_CONSTRAINT]: 'Referenced record not found',

  /**
   * User-friendly message for database operation timeouts
   */
  [ErrorCodes.DB_TIMEOUT_ERROR]: 'Database operation timed out',

  /**
   * User-friendly message for database query failures
   */
  [ErrorCodes.DB_QUERY_ERROR]: 'Database query failed',

  /**
   * User-friendly message for database transaction failures
   */
  [ErrorCodes.DB_TRANSACTION_ERROR]: 'Database transaction failed',

  /**
   * User-friendly message when database records are not found
   */
  [ErrorCodes.DB_RECORD_NOT_FOUND]: 'Record not found',

  /**
   * User-friendly message for duplicate entry attempts
   */
  [ErrorCodes.DB_DUPLICATE_ENTRY]: 'Duplicate entry not allowed',

  /**
   * User-friendly message for database deadlocks
   */
  [ErrorCodes.DB_DEADLOCK_ERROR]: 'Database deadlock detected',

  /**
   * User-friendly message for database connection limits
   */
  [ErrorCodes.DB_CONNECTION_LIMIT]: 'Database connection limit reached',

  /**
   * User-friendly message for database migration failures
   */
  [ErrorCodes.DB_MIGRATION_ERROR]: 'Database migration failed',

  /**
   * User-friendly message for database backup failures
   */
  [ErrorCodes.DB_BACKUP_ERROR]: 'Database backup failed',

  // File & Storage Messages

  /**
   * User-friendly message for file upload failures
   */
  [ErrorCodes.FILE_UPLOAD_ERROR]: 'File upload failed',

  /**
   * User-friendly message for file download failures
   */
  [ErrorCodes.FILE_DOWNLOAD_ERROR]: 'File download failed',

  /**
   * User-friendly message for file deletion failures
   */
  [ErrorCodes.FILE_DELETE_ERROR]: 'File deletion failed',

  /**
   * User-friendly message when files are not found
   */
  [ErrorCodes.FILE_NOT_FOUND]: 'File not found',

  /**
   * User-friendly message for oversized files
   */
  [ErrorCodes.FILE_TOO_LARGE]: 'File size exceeds limit',

  /**
   * User-friendly message for invalid file types
   */
  [ErrorCodes.FILE_INVALID_TYPE]: 'File type not allowed',

  /**
   * User-friendly message for invalid file names
   */
  [ErrorCodes.FILE_INVALID_NAME]: 'Invalid file name',

  /**
   * User-friendly message for storage limit exceeded
   */
  [ErrorCodes.FILE_STORAGE_LIMIT]: 'Storage limit exceeded',

  /**
   * User-friendly message for corrupted files
   */
  [ErrorCodes.FILE_CORRUPTED]: 'File is corrupted',

  /**
   * User-friendly message for file permission issues
   */
  [ErrorCodes.FILE_PERMISSION_DENIED]: 'File access denied',

  // Server & Infrastructure Messages

  /**
   * User-friendly message for internal server errors
   */
  [ErrorCodes.SRV_INTERNAL_ERROR]: 'Internal server error',

  /**
   * User-friendly message for external service failures
   */
  [ErrorCodes.SRV_EXTERNAL_SERVICE]: 'External service unavailable',

  /**
   * User-friendly message for server configuration errors
   */
  [ErrorCodes.SRV_CONFIGURATION_ERROR]: 'Server configuration error',

  /**
   * User-friendly message for encryption failures
   */
  [ErrorCodes.SRV_ENCRYPTION_ERROR]: 'Encryption failed',

  /**
   * User-friendly message for decryption failures
   */
  [ErrorCodes.SRV_DECRYPTION_ERROR]: 'Decryption failed',

  /**
   * User-friendly message for rate limiting
   */
  [ErrorCodes.SRV_RATE_LIMIT]: 'Rate limit exceeded',

  /**
   * User-friendly message for maintenance mode
   */
  [ErrorCodes.SRV_MAINTENANCE_MODE]: 'Service under maintenance',

  /**
   * User-friendly message for service unavailability
   */
  [ErrorCodes.SRV_SERVICE_UNAVAILABLE]: 'Service temporarily unavailable',

  /**
   * User-friendly message for memory limit exceeded
   */
  [ErrorCodes.SRV_MEMORY_LIMIT]: 'Memory limit exceeded',

  /**
   * User-friendly message for CPU limit exceeded
   */
  [ErrorCodes.SRV_CPU_LIMIT]: 'CPU limit exceeded',

  /**
   * User-friendly message for insufficient disk space
   */
  [ErrorCodes.SRV_DISK_SPACE]: 'Disk space insufficient',

  // Network & Communication Messages

  /**
   * User-friendly message for network connection failures
   */
  [ErrorCodes.NET_NETWORK_ERROR]: 'Network connection failed',

  /**
   * User-friendly message for connection timeouts
   */
  [ErrorCodes.NET_CONNECTION_TIMEOUT]: 'Connection timeout',

  /**
   * User-friendly message for DNS resolution failures
   */
  [ErrorCodes.NET_DNS_ERROR]: 'DNS resolution failed',

  /**
   * User-friendly message for SSL certificate errors
   */
  [ErrorCodes.NET_SSL_ERROR]: 'SSL certificate error',

  /**
   * User-friendly message for proxy connection failures
   */
  [ErrorCodes.NET_PROXY_ERROR]: 'Proxy connection failed',

  /**
   * User-friendly message for firewall blocks
   */
  [ErrorCodes.NET_FIREWALL_BLOCKED]: 'Connection blocked by firewall',

  // Payment & Billing Messages

  /**
   * User-friendly message for payment processing failures
   */
  [ErrorCodes.PAY_PAYMENT_FAILED]: 'Payment processing failed',

  /**
   * User-friendly message for insufficient funds
   */
  [ErrorCodes.PAY_INSUFFICIENT_FUNDS]: 'Insufficient funds',

  /**
   * User-friendly message for declined cards
   */
  [ErrorCodes.PAY_CARD_DECLINED]: 'Card declined',

  /**
   * User-friendly message for invalid card details
   */
  [ErrorCodes.PAY_INVALID_CARD]: 'Invalid card details',

  /**
   * User-friendly message for expired cards
   */
  [ErrorCodes.PAY_EXPIRED_CARD]: 'Card has expired',

  /**
   * User-friendly message for payment processor errors
   */
  [ErrorCodes.PAY_PROCESSOR_ERROR]: 'Payment processor error',

  /**
   * User-friendly message for refund failures
   */
  [ErrorCodes.PAY_REFUND_FAILED]: 'Refund failed',

  /**
   * User-friendly message for expired subscriptions
   */
  [ErrorCodes.PAY_SUBSCRIPTION_EXPIRED]: 'Subscription has expired',

  /**
   * User-friendly message when invoices are not found
   */
  [ErrorCodes.PAY_INVOICE_NOT_FOUND]: 'Invoice not found',

  // Notification & Email Messages

  /**
   * User-friendly message for email delivery failures
   */
  [ErrorCodes.NOTIF_EMAIL_FAILED]: 'Email sending failed',

  /**
   * User-friendly message for SMS delivery failures
   */
  [ErrorCodes.NOTIF_SMS_FAILED]: 'SMS sending failed',

  /**
   * User-friendly message for push notification failures
   */
  [ErrorCodes.NOTIF_PUSH_FAILED]: 'Push notification failed',

  /**
   * User-friendly message when notification templates are not found
   */
  [ErrorCodes.NOTIF_TEMPLATE_NOT_FOUND]: 'Notification template not found',

  /**
   * User-friendly message for notification rate limiting
   */
  [ErrorCodes.NOTIF_RATE_LIMIT]: 'Notification rate limit exceeded',

  /**
   * User-friendly message for notification provider errors
   */
  [ErrorCodes.NOTIF_PROVIDER_ERROR]: 'Notification service error',

  // Generic Messages

  /**
   * User-friendly message for general validation failures
   */
  [ErrorCodes.GEN_VALIDATION_ERROR]: 'Validation failed',

  /**
   * User-friendly message when resources are not found
   */
  [ErrorCodes.GEN_NOT_FOUND]: 'Resource not found',

  /**
   * User-friendly message for operation timeouts
   */
  [ErrorCodes.GEN_TIMEOUT]: 'Operation timed out',

  /**
   * User-friendly message for network errors
   */
  [ErrorCodes.GEN_NETWORK_ERROR]: 'Network error occurred',

  /**
   * User-friendly message for service errors
   */
  [ErrorCodes.GEN_SERVICE_ERROR]: 'Service error occurred',

  /**
   * User-friendly message for unknown errors
   */
  [ErrorCodes.GEN_UNKNOWN_ERROR]: 'An unknown error occurred',

  /**
   * User-friendly message for forbidden access
   */
  [ErrorCodes.GEN_FORBIDDEN]: 'Access forbidden',

  /**
   * User-friendly message for unauthorized access
   */
  [ErrorCodes.GEN_UNAUTHORIZED]: 'Unauthorized access',

  /**
   * User-friendly message for bad requests
   */
  [ErrorCodes.GEN_BAD_REQUEST]: 'Bad request',

  /**
   * User-friendly message for resource conflicts
   */
  [ErrorCodes.GEN_CONFLICT]: 'Resource conflict',
} as const;

/**
 * Success messages for positive user feedback and confirmation.
 *
 * Provides consistent, user-friendly success messages for various operations
 * that can be displayed to end-users to confirm successful actions.
 *
 * @namespace SuccessMessages
 *
 * @example
 * ```typescript
 * // Display success message to user
 * function showSuccessMessage(type: keyof typeof SuccessMessages) {
 *   displayNotification(SuccessMessages[type], 'success');
 * }
 *
 * // API success response
 * return response.status(HttpStatus.OK).json({
 *   success: true,
 *   message: SuccessMessages.OPERATION_SUCCESSFUL,
 *   data: result
 * });
 * ```
 */
export const SuccessMessages = {
  /**
   * Generic success message for completed operations
   */
  OPERATION_SUCCESSFUL: 'Operation completed successfully',

  /**
   * Success message for user login
   */
  LOGIN_SUCCESSFUL: 'Login successful',

  /**
   * Success message for user logout
   */
  LOGOUT_SUCCESSFUL: 'Logout successful',

  /**
   * Success message for user registration
   */
  REGISTRATION_SUCCESSFUL: 'Registration successful',

  /**
   * Success message for password reset
   */
  PASSWORD_RESET_SUCCESSFUL: 'Password reset successful',

  /**
   * Success message for email verification
   */
  EMAIL_VERIFIED: 'Email verified successfully',

  /**
   * Success message for phone number verification
   */
  PHONE_VERIFIED: 'Phone number verified successfully',

  /**
   * Success message for profile updates
   */
  PROFILE_UPDATED: 'Profile updated successfully',

  /**
   * Success message for password changes
   */
  PASSWORD_CHANGED: 'Password changed successfully',

  /**
   * Success message for file uploads
   */
  FILE_UPLOADED: 'File uploaded successfully',

  /**
   * Success message for file deletions
   */
  FILE_DELETED: 'File deleted successfully',

  /**
   * Success message for payment processing
   */
  PAYMENT_SUCCESSFUL: 'Payment processed successfully',

  /**
   * Success message for refund processing
   */
  REFUND_SUCCESSFUL: 'Refund processed successfully',

  /**
   * Success message for subscription activation
   */
  SUBSCRIPTION_ACTIVATED: 'Subscription activated successfully',

  /**
   * Success message for subscription cancellation
   */
  SUBSCRIPTION_CANCELLED: 'Subscription cancelled successfully',

  /**
   * Success message for data creation
   */
  DATA_CREATED: 'Data created successfully',

  /**
   * Success message for data updates
   */
  DATA_UPDATED: 'Data updated successfully',

  /**
   * Success message for data deletion
   */
  DATA_DELETED: 'Data deleted successfully',

  /**
   * Success message for data retrieval
   */
  DATA_RETRIEVED: 'Data retrieved successfully',
} as const;

/**
 * Informational messages for user guidance and status updates.
 *
 * Provides helpful, informative messages that guide users through processes
 * or inform them about system status without indicating errors or successes.
 *
 * @namespace InfoMessages
 *
 * @example
 * ```typescript
 * // Display informational message to user
 * function showInfoMessage(type: keyof typeof InfoMessages) {
 *   displayNotification(InfoMessages[type], 'info');
 * }
 *
 * // Show maintenance notice
 * if (isMaintenanceMode) {
 *   showInfoMessage('MAINTENANCE_SCHEDULED');
 * }
 * ```
 */
export const InfoMessages = {
  /**
   * Informational message for pending account verification
   */
  ACCOUNT_PENDING_VERIFICATION: 'Please verify your account to continue',

  /**
   * Informational message when password reset email is sent
   */
  PASSWORD_RESET_EMAIL_SENT: 'Password reset instructions sent to your email',

  /**
   * Informational message when email verification is sent
   */
  EMAIL_VERIFICATION_SENT: 'Email verification link sent to your email',

  /**
   * Informational message when multi-factor authentication is required
   */
  MFA_REQUIRED: 'Please complete multi-factor authentication',

  /**
   * Informational message for session expiration warnings
   */
  SESSION_EXPIRING_SOON: 'Your session will expire soon',

  /**
   * Informational message for scheduled maintenance
   */
  MAINTENANCE_SCHEDULED: 'Scheduled maintenance in progress',

  /**
   * Informational message for rate limit warnings
   */
  RATE_LIMIT_WARNING: 'You are approaching the rate limit',

  /**
   * Informational message for storage limit warnings
   */
  STORAGE_LIMIT_WARNING: 'You are approaching your storage limit',
} as const;

/**
 * Union type of all possible error messages in the system.
 *
 * Enables type-safe usage of error messages throughout the application.
 */
export type ErrorMessageType = (typeof ErrorMessages)[keyof typeof ErrorMessages];

/**
 * Union type of all possible success messages in the system.
 *
 * Enables type-safe usage of success messages throughout the application.
 */
export type SuccessMessageType = (typeof SuccessMessages)[keyof typeof SuccessMessages];

/**
 * Union type of all possible informational messages in the system.
 *
 * Enables type-safe usage of informational messages throughout the application.
 */
export type InfoMessageType = (typeof InfoMessages)[keyof typeof InfoMessages];
import { CertusAdiValtError } from '@/certus';
import {
  EmptyResponse,
  ErrorResponse,
  PaginatedResponse,
  PaginationParams,
  SuccessResponse,
} from '@/types';

/**
 * Response builder utility for creating standardized API responses in the CertusAdiValt system.
 *
 * Provides factory methods for creating consistent, well-structured API responses
 * following the CertusAdiValt response format standards. Ensures all responses
 * include proper timestamps, success indicators, and optional metadata.
 *
 * @class CertusResponseBuilder
 *
 * @example
 * ```typescript
 * // Success response with data
 * return CertusResponseBuilder.success(userData, 'User retrieved successfully', requestId);
 *
 * // Error response
 * try {
 *   await someOperation();
 * } catch (error) {
 *   return CertusResponseBuilder.error(error, requestId);
 * }
 *
 * // Paginated response
 * return CertusResponseBuilder.paginated(users, pagination, requestId, { totalUsers: 1000 });
 *
 * // Empty response for DELETE operations
 * return CertusResponseBuilder.deleted('User deleted successfully', requestId);
 * ```
 */
export class CertusResponseBuilder {
  /**
   * Generates an ISO 8601 timestamp for response standardization.
   *
   * @private
   * @returns {string} ISO 8601 formatted timestamp
   *
   * @example
   * ```typescript
   * const timestamp = CertusResponseBuilder.generateTimestamp();
   * // Returns: "2024-01-15T10:30:00.000Z"
   * ```
   */
  private static generateTimestamp(): string {
    return new Date().toISOString();
  }

  /**
   * Creates a standard success response with data payload.
   *
   * @template T - Type of the data payload
   * @param {T} data - The main response data payload
   * @param {string} [message] - Optional success message
   * @param {string} [requestId] - Optional request ID for tracing
   * @param {Record<string, unknown>} [meta] - Optional additional metadata
   * @returns {SuccessResponse<T>} Standardized success response
   *
   * @example
   * ```typescript
   * // Basic success response
   * return CertusResponseBuilder.success({ id: 1, name: 'John' });
   *
   * // Success response with message and metadata
   * return CertusResponseBuilder.success(
   *   userData,
   *   'User profile retrieved',
   *   'req_123456',
   *   { cache: { hit: true, ttl: 300 } }
   * );
   *
   * // Success response for array data
   * return CertusResponseBuilder.success(users, `${users.length} users found`);
   * ```
   */
  static success<T = unknown>(
    data: T,
    message?: string,
    requestId?: string,
    meta?: Record<string, unknown>
  ): SuccessResponse<T> {
    return {
      success: true,
      data,
      message,
      timestamp: this.generateTimestamp(),
      requestId,
      meta,
    };
  }

  /**
   * Creates a standardized error response from any error object.
   *
   * Automatically handles both CertusAdiValtError instances and generic Error objects,
   * providing appropriate error code, message, and status code mapping.
   *
   * @param {CertusAdiValtError | Error} error - The error to convert to response format
   * @param {string} [requestId] - Optional request ID for tracing
   * @returns {ErrorResponse} Standardized error response
   *
   * @example
   * ```typescript
   * // From CertusAdiValtError
   * try {
   *   await authenticateUser(credentials);
   * } catch (error) {
   *   if (error instanceof CertusAdiValtError) {
   *     return CertusResponseBuilder.error(error, requestId);
   *   }
   *   // Handle generic errors
   *   return CertusResponseBuilder.error(error, requestId);
   * }
   *
   * // From generic Error
   * try {
   *   JSON.parse(invalidJson);
   * } catch (error) {
   *   return CertusResponseBuilder.error(error, 'req_123456');
   * }
   * ```
   */
  static error(error: CertusAdiValtError | Error, requestId?: string): ErrorResponse {
    const isCertusError = error instanceof CertusAdiValtError;

    return {
      success: false,
      error: {
        code: isCertusError ? error.code : 'UNKNOWN_ERROR',
        message: error.message,
        details: isCertusError ? undefined : 'An unexpected error occurred',
        statusCode: isCertusError ? error.statusCode : 500,
        timestamp: this.generateTimestamp(),
        context: isCertusError ? error.context : undefined,
        requestId,
      },
    };
  }

  /**
   * Creates a paginated response for list endpoints with pagination metadata.
   *
   * @template T - Type of items in the data array
   * @param {T[]} data - Array of paginated items
   * @param {PaginationParams} pagination - Pagination metadata
   * @param {string} [requestId] - Optional request ID for tracing
   * @param {Record<string, unknown>} [meta] - Optional additional metadata
   * @returns {PaginatedResponse<T>} Standardized paginated response
   *
   * @example
   * ```typescript
   * // Basic paginated response
   * const pagination = {
   *   page: 1,
   *   limit: 20,
   *   total: 150,
   *   totalPages: 8,
   *   hasNext: true,
   *   hasPrev: false
   * };
   * return CertusResponseBuilder.paginated(users, pagination, requestId);
   *
   * // Paginated response with additional metadata
   * return CertusResponseBuilder.paginated(
   *   products,
   *   pagination,
   *   requestId,
   *   {
   *     filters: { category: 'electronics' },
   *     sort: { field: 'price', order: 'asc' }
   *   }
   * );
   * ```
   */
  static paginated<T = unknown>(
    data: T[],
    pagination: PaginationParams,
    requestId?: string,
    meta?: Record<string, unknown>
  ): PaginatedResponse<T> {
    return {
      success: true,
      data,
      pagination,
      timestamp: this.generateTimestamp(),
      requestId,
      meta,
    };
  }

  /**
   * Creates an empty success response for operations that don't return data.
   *
   * Typically used for DELETE operations or other actions where no data payload
   * is returned, but a success confirmation is needed.
   *
   * @param {string} [message] - Optional success message
   * @param {string} [requestId] - Optional request ID for tracing
   * @returns {EmptyResponse} Standardized empty success response
   *
   * @example
   * ```typescript
   * // Basic empty response
   * return CertusResponseBuilder.empty();
   *
   * // Empty response with custom message
   * return CertusResponseBuilder.empty('Operation completed successfully', 'req_123456');
   *
   * // For DELETE endpoints
   * await userRepository.delete(userId);
   * return CertusResponseBuilder.empty('User deleted successfully', requestId);
   * ```
   */
  static empty(message?: string, requestId?: string): EmptyResponse {
    return {
      success: true,
      message,
      timestamp: this.generateTimestamp(),
      requestId,
    };
  }

  /**
   * Creates a success response specifically for resource creation (HTTP 201 equivalent).
   *
   * Convenience method for POST endpoints that create new resources.
   *
   * @template T - Type of the created resource data
   * @param {T} data - The created resource data
   * @param {string} [message='Resource created successfully'] - Success message
   * @param {string} [requestId] - Optional request ID for tracing
   * @returns {SuccessResponse<T>} Standardized creation success response
   *
   * @example
   * ```typescript
   * // Create user response
   * const newUser = await userRepository.create(userData);
   * return CertusResponseBuilder.created(newUser, 'User created successfully', requestId);
   *
   * // Create with custom message
   * return CertusResponseBuilder.created(
   *   product,
   *   'Product added to catalog',
   *   requestId
   * );
   * ```
   */
  static created<T = unknown>(
    data: T,
    message: string = 'Resource created successfully',
    requestId?: string
  ): SuccessResponse<T> {
    return this.success(data, message, requestId);
  }

  /**
   * Creates a success response specifically for resource updates (HTTP 200/204 equivalent).
   *
   * Convenience method for PUT/PATCH endpoints that update existing resources.
   *
   * @template T - Type of the updated resource data
   * @param {T} data - The updated resource data
   * @param {string} [message='Resource updated successfully'] - Success message
   * @param {string} [requestId] - Optional request ID for tracing
   * @returns {SuccessResponse<T>} Standardized update success response
   *
   * @example
   * ```typescript
   * // Update user response
   * const updatedUser = await userRepository.update(userId, updateData);
   * return CertusResponseBuilder.updated(updatedUser, 'User profile updated', requestId);
   *
   * // Partial update response
   * return CertusResponseBuilder.updated(
   *   partialUser,
   *   'User preferences updated',
   *   requestId
   * );
   * ```
   */
  static updated<T = unknown>(
    data: T,
    message: string = 'Resource updated successfully',
    requestId?: string
  ): SuccessResponse<T> {
    return this.success(data, message, requestId);
  }

  /**
   * Creates an empty success response specifically for resource deletion.
   *
   * Convenience method for DELETE endpoints that remove resources.
   *
   * @param {string} [message='Resource deleted successfully'] - Success message
   * @param {string} [requestId] - Optional request ID for tracing
   * @returns {EmptyResponse} Standardized deletion success response
   *
   * @example
   * ```typescript
   * // Delete user response
   * await userRepository.delete(userId);
   * return CertusResponseBuilder.deleted('User account deleted', requestId);
   *
   * // Delete with custom message
   * return CertusResponseBuilder.deleted(
   *   'Product removed from inventory',
   *   requestId
   * );
   * ```
   */
  static deleted(
    message: string = 'Resource deleted successfully',
    requestId?: string
  ): EmptyResponse {
    return this.empty(message, requestId);
  }
}
import { ApiResponse } from '@/types';
import { CertusResponseBuilder } from '../builder';
import { CertusAdiValtError } from '@/certus';

/**
 * High-level response formatting utility for the CertusAdiValt system.
 *
 * Provides simplified, opinionated methods for formatting API responses with
 * sensible defaults and enhanced error handling. Acts as a facade over the
 * more granular CertusResponseBuilder for common use cases.
 *
 * @class ResponseFormatter
 *
 * @example
 * ```typescript
 * // In API controllers
 * return ResponseFormatter.formatSuccess(userData, {
 *   message: 'User retrieved successfully',
 *   requestId: req.requestId
 * });
 *
 * // Automatic error handling
 * try {
 *   await someOperation();
 * } catch (error) {
 *   return ResponseFormatter.formatError(error, {
 *     requestId: req.requestId,
 *     includeDetails: process.env.NODE_ENV === 'development'
 *   });
 * }
 *
 * // Simplified pagination
 * return ResponseFormatter.formatPaginated(users, {
 *   page: 1,
 *   limit: 20,
 *   total: 150
 * }, {
 *   requestId: req.requestId
 * });
 * ```
 */
export class ResponseFormatter {
  /**
   * Formats a successful API response with data payload.
   *
   * Provides a simplified interface for success responses with optional
   * message, request ID, and metadata. Wraps the CertusResponseBuilder.success()
   * method with a more convenient options object.
   *
   * @template T - Type of the data payload
   * @param {T} data - The main response data payload
   * @param {Object} [options] - Response formatting options
   * @param {string} [options.message] - Optional success message
   * @param {string} [options.requestId] - Optional request ID for tracing
   * @param {Record<string, unknown>} [options.meta] - Optional additional metadata
   * @returns {ApiResponse<T>} Formatted success response
   *
   * @example
   * ```typescript
   * // Basic success response
   * return ResponseFormatter.formatSuccess({ id: 1, name: 'John' });
   *
   * // Success with all options
   * return ResponseFormatter.formatSuccess(
   *   userData,
   *   {
   *     message: 'User profile retrieved successfully',
   *     requestId: 'req_123456',
   *     meta: {
   *       cache: { hit: true, ttl: 300 },
   *       permissions: ['read', 'write']
   *     }
   *   }
   * );
   *
   * // Array data with metadata
   * return ResponseFormatter.formatSuccess(products, {
   *   message: `${products.length} products found`,
   *   meta: { category: 'electronics', inStock: true }
   * });
   * ```
   */
  static formatSuccess<T = unknown>(
    data: T,
    options: {
      message?: string;
      requestId?: string;
      meta?: Record<string, unknown>;
    } = {}
  ): ApiResponse<T> {
    return CertusResponseBuilder.success(data, options.message, options.requestId, options.meta);
  }

  /**
   * Formats an error response from any type of error with enhanced handling.
   *
   * Automatically handles different error types and provides appropriate formatting:
   * - CertusAdiValtError: Preserves original error structure and context
   * - Error: Converts to CertusAdiValtError with optional detail masking
   * - Unknown: Creates generic internal server error response
   *
   * @param {unknown} error - The error to format (any type)
   * @param {Object} [options] - Error formatting options
   * @param {string} [options.requestId] - Optional request ID for tracing
   * @param {boolean} [options.includeDetails=false] - Whether to include detailed error messages in production
   * @returns {ApiResponse} Formatted error response
   *
   * @example
   * ```typescript
   * // Handle CertusAdiValtError (preserves original structure)
   * try {
   *   await userService.authenticate(credentials);
   * } catch (error) {
   *   return ResponseFormatter.formatError(error, {
   *     requestId: req.requestId
   *   });
   * }
   *
   * // Handle generic errors with detail masking
   * try {
   *   JSON.parse(invalidJson);
   * } catch (error) {
   *   return ResponseFormatter.formatError(error, {
   *     requestId: req.requestId,
   *     includeDetails: process.env.NODE_ENV === 'development' // Show details only in dev
   *   });
   * }
   *
   * // Handle unknown error types safely
   * try {
   *   await someRiskyOperation();
   * } catch (error) {
   *   // Even if error is not an Error instance, this will handle it gracefully
   *   return ResponseFormatter.formatError(error, {
   *     requestId: req.requestId
   *   });
   * }
   * ```
   */
  static formatError(
    error: unknown,
    options: {
      requestId?: string;
      includeDetails?: boolean;
    } = {}
  ): ApiResponse {
    // Handle CertusAdiValtError instances (preserve original structure)
    if (error instanceof CertusAdiValtError) {
      return CertusResponseBuilder.error(error, options.requestId);
    }

    // Handle standard Error instances
    if (error instanceof Error) {
      const certusError = new CertusAdiValtError(
        options.includeDetails ? error.message : 'Internal server error',
        'SRV_INTERNAL_ERROR',
        500,
        {},
        error
      );
      return CertusResponseBuilder.error(certusError, options.requestId);
    }

    // Handle unknown error types (non-Error objects, strings, etc.)
    const certusError = new CertusAdiValtError(
      'An unexpected error occurred',
      'SRV_INTERNAL_ERROR',
      500
    );
    return CertusResponseBuilder.error(certusError, options.requestId);
  }

  /**
   * Formats a paginated response with automatic pagination metadata calculation.
   *
   * Simplifies paginated responses by automatically calculating derived pagination
   * fields (totalPages, hasNext, hasPrev) from basic pagination parameters.
   *
   * @template T - Type of items in the data array
   * @param {T[]} data - Array of paginated items
   * @param {Object} pagination - Basic pagination parameters
   * @param {number} pagination.page - Current page number (1-based)
   * @param {number} pagination.limit - Number of items per page
   * @param {number} pagination.total - Total number of items across all pages
   * @param {Object} [options] - Pagination formatting options
   * @param {string} [options.requestId] - Optional request ID for tracing
   * @param {Record<string, unknown>} [options.meta] - Optional additional metadata
   * @returns {ApiResponse<T>} Formatted paginated response
   *
   * @example
   * ```typescript
   * // Basic pagination
   * return ResponseFormatter.formatPaginated(
   *   users,
   *   {
   *     page: 1,
   *     limit: 20,
   *     total: 150
   *   },
   *   {
   *     requestId: req.requestId
   *   }
   * );
   *
   * // Pagination with metadata
   * return ResponseFormatter.formatPaginated(
   *   products,
   *   {
   *     page: 2,
   *     limit: 25,
   *     total: 1000
   *   },
   *   {
   *     requestId: req.requestId,
   *     meta: {
   *       filters: { category: 'electronics', priceRange: '100-500' },
   *       sort: { by: 'name', order: 'asc' }
   *     }
   *   }
   * );
   *
   * // Empty pagination result
   * return ResponseFormatter.formatPaginated(
   *   [],
   *   {
   *     page: 1,
   *     limit: 20,
   *     total: 0
   *   },
   *   {
   *     message: 'No results found for your search criteria'
   *   }
   * );
   * ```
   */
  static formatPaginated<T = unknown>(
    data: T[],
    pagination: {
      page: number;
      limit: number;
      total: number;
    },
    options: {
      requestId?: string;
      meta?: Record<string, unknown>;
    } = {}
  ): ApiResponse<T> {
    // Calculate derived pagination fields
    const totalPages = Math.ceil(pagination.total / pagination.limit);
    const hasNext = pagination.page < totalPages;
    const hasPrev = pagination.page > 1;

    const paginationParams = {
      page: pagination.page,
      limit: pagination.limit,
      total: pagination.total,
      totalPages,
      hasNext,
      hasPrev,
    };

    return CertusResponseBuilder.paginated(data, paginationParams, options.requestId, options.meta);
  }
}
import {
  ApiResponse,
  EmptyResponse,
  ErrorResponse,
  PaginatedResponse,
  SuccessResponse,
} from '@/types';

/**
 * Type guard to check if an API response is a success response with data.
 *
 * Provides runtime type checking to safely determine if an API response
 * is a successful response containing a data payload. This enables
 * type-safe access to the data property in TypeScript.
 *
 * @template T - The expected type of the data payload
 * @param {ApiResponse<T>} response - The API response to check
 * @returns {response is SuccessResponse<T>} True if the response is a success response with data
 *
 * @example
 * ```typescript
 * // Type-safe response handling
 * const response = await fetchUserData();
 *
 * if (isSuccessResponse(response)) {
 *   // TypeScript now knows response is SuccessResponse<User>
 *   console.log(response.data.name); // Safe access to data
 *   console.log(response.data.email); // Safe access to data
 * }
 *
 * // In conditional logic
 * function handleResponse<T>(response: ApiResponse<T>) {
 *   if (isSuccessResponse(response)) {
 *     processData(response.data); // response.data is type T
 *     return response.data;
 *   }
 *   throw new Error('Operation failed');
 * }
 *
 * // With async/await patterns
 * async function fetchData(): Promise<User> {
 *   const response = await api.get<User>('/users/123');
 *
 *   if (isSuccessResponse(response)) {
 *     return response.data; // Type is User
 *   }
 *
 *   throw new Error('Failed to fetch user data');
 * }
 * ```
 */
export function isSuccessResponse<T = unknown>(
  response: ApiResponse<T>
): response is SuccessResponse<T> {
  return response.success === true && 'data' in response;
}

/**
 * Type guard to check if an API response is an error response.
 *
 * Provides runtime type checking to safely determine if an API response
 * is an error response. This enables type-safe access to error details
 * and proper error handling.
 *
 * @param {ApiResponse} response - The API response to check
 * @returns {response is ErrorResponse} True if the response is an error response
 *
 * @example
 * ```typescript
 * // Safe error handling
 * const response = await apiCall();
 *
 * if (isErrorResponse(response)) {
 *   // TypeScript now knows response is ErrorResponse
 *   console.error(response.error.message); // Safe access to error
 *   console.error(response.error.code); // Safe access to error code
 *
 *   // Handle specific error types
 *   if (response.error.code === 'AUTH_INVALID_CREDENTIALS') {
 *     redirectToLogin();
 *   }
 * }
 *
 * // In error processing middleware
 * function processErrorResponse(response: ApiResponse) {
 *   if (isErrorResponse(response)) {
 *     logger.error('API Error:', {
 *       code: response.error.code,
 *       message: response.error.message,
 *       statusCode: response.error.statusCode
 *     });
 *
 *     if (response.error.statusCode >= 500) {
 *       notifyOperationsTeam(response.error);
 *     }
 *   }
 * }
 *
 * // With conditional error handling
 * function handleApiResponse(response: ApiResponse) {
 *   if (isErrorResponse(response)) {
 *     switch (response.error.statusCode) {
 *       case 401:
 *         handleUnauthorizedError(response.error);
 *         break;
 *       case 404:
 *         handleNotFoundError(response.error);
 *         break;
 *       default:
 *         handleGenericError(response.error);
 *     }
 *   }
 * }
 * ```
 */
export function isErrorResponse(response: ApiResponse): response is ErrorResponse {
  return response.success === false && 'error' in response;
}

/**
 * Type guard to check if an API response is a paginated response.
 *
 * Provides runtime type checking to safely determine if an API response
 * is a paginated list response. This enables type-safe access to both
 * the data array and pagination metadata.
 *
 * @template T - The expected type of items in the data array
 * @param {ApiResponse<T>} response - The API response to check
 * @returns {response is PaginatedResponse<T>} True if the response is a paginated response
 *
 * @example
 * ```typescript
 * // Handling paginated lists
 * const response = await fetchUsers({ page: 1, limit: 20 });
 *
 * if (isPaginatedResponse(response)) {
 *   // TypeScript now knows response is PaginatedResponse<User>
 *   console.log(response.data.length); // Safe access to data array
 *   console.log(response.pagination.totalPages); // Safe access to pagination
 *   console.log(response.pagination.hasNext); // Safe access to pagination
 *
 *   // Render pagination controls
 *   renderPaginationControls(response.pagination);
 * }
 *
 * // In data table components
 * function DataTable<T>({ response }: { response: ApiResponse<T[]> }) {
 *   if (isPaginatedResponse(response)) {
 *     return (
 *       <div>
 *         <Table data={response.data} />
 *         <Pagination
 *           currentPage={response.pagination.page}
 *           totalPages={response.pagination.totalPages}
 *           hasNext={response.pagination.hasNext}
 *           hasPrev={response.pagination.hasPrev}
 *         />
 *       </div>
 *     );
 *   }
 *
 *   return <ErrorMessage response={response} />;
 * }
 *
 * // With pagination utilities
 * function extractPaginationData<T>(response: ApiResponse<T[]>) {
 *   if (isPaginatedResponse(response)) {
 *     return {
 *       items: response.data,
 *       pageInfo: response.pagination,
 *       totalCount: response.pagination.total
 *     };
 *   }
 *   return null;
 * }
 * ```
 */
export function isPaginatedResponse<T = unknown>(
  response: ApiResponse<T>
): response is PaginatedResponse<T> {
  return response.success === true && 'pagination' in response;
}

/**
 * Type guard to check if an API response is an empty success response.
 *
 * Provides runtime type checking to safely determine if an API response
 * is a success response without any data payload (typically used for
 * DELETE operations or other actions that don't return data).
 *
 * @param {ApiResponse} response - The API response to check
 * @returns {response is EmptyResponse} True if the response is an empty success response
 *
 * @example
 * ```typescript
 * // Handling delete operations
 * const response = await deleteUser(userId);
 *
 * if (isEmptyResponse(response)) {
 *   // TypeScript now knows response is EmptyResponse
 *   console.log(response.message); // Safe access to optional message
 *   showSuccessNotification(response.message || 'Operation completed successfully');
 *
 *   // Refresh the UI state
 *   refreshUserList();
 * }
 *
 * // In API client methods
 * async function deleteResource(id: string): Promise<void> {
 *   const response = await api.delete(`/resources/${id}`);
 *
 *   if (isEmptyResponse(response)) {
 *     // Success - no data returned, but operation completed
 *     return;
 *   }
 *
 *   if (isErrorResponse(response)) {
 *     throw new Error(response.error.message);
 *   }
 *
 *   throw new Error('Unexpected response type');
 * }
 *
 * // With conditional UI updates
 * function handleOperationResult(response: ApiResponse) {
 *   if (isEmptyResponse(response)) {
 *     // Show success message for operations without return data
 *     showToast({
 *       type: 'success',
 *       message: response.message || 'Operation completed'
 *     });
 *     return;
 *   }
 *
 *   if (isSuccessResponse(response)) {
 *     // Show success message with data summary
 *     showToast({
 *       type: 'success',
 *       message: `Operation completed: ${response.data}`
 *     });
 *     return;
 *   }
 * }
 * ```
 */
export function isEmptyResponse(response: ApiResponse): response is EmptyResponse {
  return response.success === true && !('data' in response) && !('pagination' in response);
}
/**
 * Represents the current runtime environment of the application.
 *
 * - `development` → Local development
 * - `stagging` → Pre-production/testing
 * - `production` → Live production
 * - `test` → Automated test environment
 */
export type Environment = 'development' | 'stagging' | 'production' | 'test';

/**
 * Logging severity levels used across the system.
 */
export enum LogLevel {
  /** Critical failures or crashes */
  ERROR = 0,

  /** Recoverable issues, bad input, unexpected flows */
  WARN = 1,

  /** High-level application events */
  INFO = 2,

  /** Low-level debug events */
  DEBUG = 3,

  /** Extremely detailed tracing information */
  TRACE = 4,
}

/**
 * Base context shared across logger, errors, responses.
 * Extend this to attach additional metadata to logs and errors.
 */
export interface BaseContext {
  /** Timestamp when the event occurred */
  timestamp: Date;

  /** Unique ID for tracking a request across services */
  requestId?: string;

  /** ID of the authenticated user (if any) */
  userId?: string;

  /** Session identifier (if any) */
  sessionId?: string;

  /** Additional context fields */
  [key: string]: unknown;
}

/**
 * Pagination details used in paginated responses.
 */
export interface PaginationParams {
  /** Current page number */
  page: number;

  /** Number of items per page */
  limit: number;

  /** Total number of records */
  total: number;

  /** Total number of pages */
  totalPages: number;

  /** Whether the next page exists */
  hasNext: boolean;

  /** Whether the previous page exists */
  hasPrev: boolean;
}

/**
 * Main configuration object for the CertusAdiValt package.
 * Controls error formatting, logging behavior, and API responses.
 */
export interface CertusAdiValtConfig {
  errors: {
    /** Include stack traces in error output */
    includeStack: boolean;

    /** Log errors internally */
    logErrors: boolean;

    /** Expose error details to client (disable in production) */
    exposeDetails: boolean;

    /**
     * Custom function to format errors.
     * Overrides the default error formatter.
     */
    formatError?: (error: Error) => Record<string, any>;
  };

  logger: {
    /** Minimum logging level */
    level: LogLevel;

    /** Name of the running service/app */
    service: string;

    /** Environment name */
    environment: Environment;

    /** Fields to hide from logs (ex: passwords, tokens) */
    redactFields: string[];

    /** Beautify logs instead of JSON */
    prettyPrint: boolean;

    /** Timestamp formatting pattern */
    timestampFormat: string;

    /** Application version */
    version?: string;
  };

  responses: {
    /** Whether to include timestamp in every response */
    includeTimestamp: boolean;

    /** Whether to include requestId */
    includeRequestId: boolean;

    /** Default success message */
    successMessage?: string;

    /** Pagination configuration */
    pagination: {
      /** Default page number */
      defaultPage: number;

      /** Default page size */
      defaultLimit: number;

      /** Maximum allowed limit */
      maxLimit: number;
    };
  };

  middleware: {
    /** Enable built-in error handler middleware */
    enableErrorHandler: boolean;

    /** Enable logging middleware */
    enableLogging: boolean;

    /** Enable security middleware */
    enableSecurity: boolean;

    /** Skip middleware for these paths */
    skipPaths: string[];
  };
}
import { BaseContext } from './common';

/**
 * Additional metadata provided when an error occurs.
 * Extends BaseContext to add error-specific information.
 */
export interface ErrorContext extends BaseContext {
  /** Unique error code */
  code: string;

  /** HTTP status code */
  statusCode: number;

  /** Human-readable details */
  details?: string;

  /** Stack trace (included based on config) */
  stack?: string;

  /** The original thrown error */
  originalError?: unknown;

  /** Additional custom fields */
  [key: string]: unknown;
}

/**
 * Options used when creating a new CertusError instance.
 */
export interface CertusErrorOptions {
  /** Unique error code */
  code: string;

  /** HTTP status code */
  statusCode: number;

  /** Extra contextual metadata */
  context?: Record<string, unknown>;

  /** Original thrown error (if wrapping one) */
  originalError?: Error;

  /** Force include/exclude stack trace */
  includeStack?: boolean;
}
import { BaseContext, LogLevel } from './common';

/**
 * Represents a single log entry.
 * Contains metadata, contextual fields, and optional error info.
 */
export interface LogEntry extends BaseContext {
  /** Log severity level */
  level: LogLevel;

  /** Log message */
  message: string;

  /** Name of the service emitting the log */
  service: string;

  /** Runtime environment */
  environment: string;

  /** Application version */
  version: string;

  /** Additional structured log context */
  context?: Record<string, unknown>;

  /** Error details for error logs */
  error?: {
    name: string;
    message: string;
    stack?: string;
    code?: string;
    statusCode?: number;
  };

  /** Duration of event in ms (useful for performance logs) */
  duration?: number;
}

/**
 * Logger configuration for initializing the logging system.
 */
export interface LoggerConfig {
  /** Minimum log level */
  level: LogLevel;

  /** Service/app name */
  service: string;

  /** Application environment */
  environment: string;

  /** Optional version string */
  version?: string;

  /** Sensitive fields to redact */
  redactFields?: string[];

  /** Enable pretty output */
  prettyPrint?: boolean;

  /** Timestamp formatting */
  timestampFormat?: string;
}
import type { PaginationParams } from './common';

/**
 * Success response wrapper for standard API results.
 *
 * @template T - Type of returned data
 */
export interface SuccessResponse<T = unknown> {
  success: true;

  /** Main response payload */
  data: T;

  /** Optional success message */
  message?: string;

  /** ISO timestamp */
  timestamp: string;

  /** Request tracing ID */
  requestId?: string;

  /** Extra metadata */
  meta?: Record<string, unknown>;
}

/**
 * Standard structure for error API responses.
 */
export interface ErrorResponse {
  success: false;

  error: {
    /** Machine-readable error code */
    code: string;

    /** Human-readable message */
    message: string;

    /** Developer-friendly details */
    details?: string;

    /** HTTP status code */
    statusCode: number;

    /** ISO timestamp */
    timestamp: string;

    /** Additional contextual data */
    context?: Record<string, unknown>;

    /** Request tracking ID */
    requestId?: string;
  };
}

/**
 * Paginated list response.
 *
 * @template T - Item type
 */
export interface PaginatedResponse<T = unknown> {
  success: true;

  /** List of items */
  data: T[];

  /** Pagination metadata */
  pagination: PaginationParams;

  /** ISO timestamp */
  timestamp: string;

  /** Request ID */
  requestId?: string;

  /** Extra meta fields */
  meta?: Record<string, unknown>;
}

/**
 * Response used when no data is returned (e.g., DELETE).
 */
export interface EmptyResponse {
  success: true;

  /** Optional message */
  message?: string;

  /** ISO timestamp */
  timestamp: string;

  /** Request ID */
  requestId?: string;
}

/**
 * Union of all possible API response shapes.
 */
export type ApiResponse<T = unknown> =
  | SuccessResponse<T>
  | ErrorResponse
  | PaginatedResponse<T>
  | EmptyResponse;
import { LogEntry, LoggerConfig, LogLevel } from '@/types';

/**
 * JSON formatter for structured logging in the CertusAdiValt system.
 *
 * Transforms LogEntry objects into JSON strings with consistent formatting,
 * timestamp normalization, and configurable output structure. Ensures all
 * log entries follow a standardized JSON format for easy parsing and analysis
 * by log aggregation systems.
 *
 * @class JsonFormat
 *
 * @example
 * ```typescript
 * // Create formatter with configuration
 * const formatter = new JsonFormat({
 *   level: LogLevel.INFO,
 *   service: 'user-service',
 *   environment: 'production',
 *   version: '1.0.0',
 *   redactFields: ['password', 'token'],
 *   prettyPrint: false,
 *   timestampFormat: 'ISO'
 * });
 *
 * // Format log entry
 * const logEntry: LogEntry = {
 *   timestamp: new Date(),
 *   level: LogLevel.INFO,
 *   message: 'User login successful',
 *   service: 'user-service',
 *   environment: 'production',
 *   version: '1.0.0',
 *   requestId: 'req_123456',
 *   userId: 'user_789',
 *   context: { loginMethod: 'email', ip: '192.168.1.1' }
 * };
 *
 * const jsonOutput = formatter.format(logEntry);
 * // Output: {"timestamp":"2024-01-15T10:30:00.000Z","level":"INFO","service":"user-service",...}
 * ```
 */
export class JsonFormat {
  /**
   * Creates a new JSON formatter instance.
   *
   * @param {Required<LoggerConfig>} config - Required logger configuration
   *
   * @example
   * ```typescript
   * const config: Required<LoggerConfig> = {
   *   level: LogLevel.DEBUG,
   *   service: 'api-gateway',
   *   environment: 'development',
   *   version: '2.1.0',
   *   redactFields: ['authorization', 'cookie'],
   *   prettyPrint: true,
   *   timestampFormat: 'ISO'
   * };
   *
   * const formatter = new JsonFormat(config);
   * ```
   */
  constructor(private config: Required<LoggerConfig>) {}

  /**
   * Formats a LogEntry into a JSON string with consistent structure.
   *
   * Transforms the log entry into a structured JSON object with all optional
   * fields included only when they have values. Ensures consistent field ordering
   * and handles timestamp formatting according to configuration.
   *
   * @param {LogEntry} entry - The log entry to format
   * @returns {string} JSON string representation of the log entry
   *
   * @example
   * ```typescript
   * // Basic log entry
   * const basicEntry: LogEntry = {
   *   timestamp: new Date('2024-01-15T10:30:00.000Z'),
   *   level: LogLevel.INFO,
   *   message: 'Service started',
   *   service: 'auth-service',
   *   environment: 'production',
   *   version: '1.0.0'
   * };
   *
   * const json = formatter.format(basicEntry);
   * // Result:
   * // {
   * //   "timestamp": "2024-01-15T10:30:00.000Z",
   * //   "level": "INFO",
   * //   "service": "auth-service",
   * //   "environment": "production",
   * //   "version": "1.0.0",
   * //   "message": "Service started"
   * // }
   *
   * // Complex log entry with error and context
   * const errorEntry: LogEntry = {
   *   timestamp: new Date(),
   *   level: LogLevel.ERROR,
   *   message: 'Database connection failed',
   *   service: 'user-service',
   *   environment: 'staging',
   *   version: '1.2.0',
   *   requestId: 'req_abc123',
   *   userId: 'user_456',
   *   context: {
   *     database: 'users_db',
   *     host: 'db.example.com',
   *     port: 5432
   *   },
   *   error: {
   *     name: 'ConnectionError',
   *     message: 'Connection timeout',
   *     stack: 'Error: Connection timeout\n    at connect...'
   *   },
   *   duration: 150 // ms
   * };
   *
   * const errorJson = formatter.format(errorEntry);
   * ```
   */
  format(entry: LogEntry): string {
    const formattedEntry = {
      timestamp: this.formatTimestamp(entry.timestamp),
      level: LogLevel[entry.level],
      service: entry.service,
      environment: entry.environment,
      version: entry.version,
      message: entry.message,
      ...(entry.context && { context: entry.context }),
      ...(entry.error && { error: entry.error }),
      ...(entry.duration && { duration: entry.duration }),
      ...(entry.requestId && { requestId: entry.requestId }),
      ...(entry.userId && { userId: entry.userId }),
      ...(entry.sessionId && { sessionId: entry.sessionId }),
    };

    return JSON.stringify(formattedEntry);
  }

  /**
   * Formats a timestamp according to the configured timestamp format.
   *
   * @private
   * @param {Date} timestamp - The timestamp to format
   * @returns {string} Formatted timestamp string
   *
   * @example
   * ```typescript
   * // ISO format: "2024-01-15T10:30:00.000Z"
   * // UTC format: "Mon, 15 Jan 2024 10:30:00 GMT"
   * // LOCAL format: "1/15/2024, 10:30:00 AM"
   * ```
   */
  private formatTimestamp(timestamp: Date): string {
    switch (this.config.timestampFormat) {
      case 'ISO':
        return timestamp.toISOString();
      case 'UTC':
        return timestamp.toUTCString();
      case 'LOCAL':
        return timestamp.toLocaleString();
      default:
        return timestamp.toISOString();
    }
  }
}
import { LogEntry, LogLevel, LoggerConfig } from '@/types';

/**
 * Pretty formatter for human-readable console logging in the CertusAdiValt system.
 *
 * Transforms LogEntry objects into colorful, formatted strings optimized for
 * human readability during development and debugging. Includes ANSI color codes
 * for different log levels and structured output for context and error information.
 *
 * @class PrettyFormat
 *
 * @example
 * ```typescript
 * // Create pretty formatter for development
 * const formatter = new PrettyFormat({
 *   level: LogLevel.DEBUG,
 *   service: 'user-service',
 *   environment: 'development',
 *   version: '1.0.0',
 *   redactFields: ['password', 'token'],
 *   prettyPrint: true,
 *   timestampFormat: 'LOCAL'
 * });
 *
 * // Format log entry with colors and structure
 * const logEntry: LogEntry = {
 *   timestamp: new Date(),
 *   level: LogLevel.INFO,
 *   message: 'User login successful',
 *   service: 'user-service',
 *   environment: 'development',
 *   version: '1.0.0',
 *   requestId: 'req_123456',
 *   userId: 'user_789',
 *   context: { loginMethod: 'email', ip: '192.168.1.1' }
 * };
 *
 * const prettyOutput = formatter.format(logEntry);
 * // Output (with colors):
 * // [1/15/2024, 10:30:00 AM] INFO  user-service: User login successful
 * ```
 */
export class PrettyFormat {
  /**
   * ANSI color codes mapped to log levels for terminal output.
   *
   * @private
   */
  private colors = {
    [LogLevel.ERROR]: '\x1b[31m', // Red for errors
    [LogLevel.WARN]: '\x1b[33m', // Yellow for warnings
    [LogLevel.INFO]: '\x1b[36m', // Cyan for info
    [LogLevel.DEBUG]: '\x1b[35m', // Magenta for debug
    [LogLevel.TRACE]: '\x1b[90m', // Gray for trace
  };

  /**
   * ANSI reset code to restore terminal default colors.
   *
   * @private
   */
  private reset = '\x1b[0m';

  /**
   * Creates a new pretty formatter instance.
   *
   * @param {Required<LoggerConfig>} config - Required logger configuration
   *
   * @example
   * ```typescript
   * const config: Required<LoggerConfig> = {
   *   level: LogLevel.DEBUG,
   *   service: 'api-service',
   *   environment: 'development',
   *   version: '2.1.0',
   *   redactFields: ['authorization', 'cookie'],
   *   prettyPrint: true,
   *   timestampFormat: 'LOCAL'
   * };
   *
   * const formatter = new PrettyFormat(config);
   * ```
   */
  constructor(private config: Required<LoggerConfig>) {}

  /**
   * Formats a LogEntry into a colorful, human-readable string.
   *
   * Creates a multi-line formatted output with colors, timestamps, and
   * structured presentation of context and error information. Optimized
   * for development and debugging in terminal environments.
   *
   * @param {LogEntry} entry - The log entry to format
   * @returns {string} Colorful, formatted string representation of the log entry
   *
   * @example
   * ```typescript
   * // Basic info log
   * const infoEntry: LogEntry = {
   *   timestamp: new Date('2024-01-15T10:30:00.000Z'),
   *   level: LogLevel.INFO,
   *   message: 'Service started successfully',
   *   service: 'auth-service',
   *   environment: 'development',
   *   version: '1.0.0'
   * };
   *
   * const output = formatter.format(infoEntry);
   * // Output (cyan color):
   * // [1/15/2024, 10:30:00 AM] INFO  auth-service: Service started successfully
   *
   * // Error log with context and stack trace
   * const errorEntry: LogEntry = {
   *   timestamp: new Date(),
   *   level: LogLevel.ERROR,
   *   message: 'Database connection failed',
   *   service: 'user-service',
   *   environment: 'development',
   *   version: '1.2.0',
   *   context: {
   *     database: 'users_db',
   *     host: 'db.example.com',
   *     port: 5432,
   *     timeout: 5000
   *   },
   *   error: {
   *     name: 'ConnectionError',
   *     message: 'Connection timeout after 5000ms',
   *     stack: 'Error: Connection timeout...\n    at Connection.connect...'
   *   },
   *   duration: 5234
   * };
   *
   * const errorOutput = formatter.format(errorEntry);
   * // Output (red color):
   * // [1/15/2024, 10:30:00 AM] ERROR user-service: Database connection failed
   * //   Context: {
   * //     "database": "users_db",
   * //     "host": "db.example.com",
   * //     "port": 5432,
   * //     "timeout": 5000
   * //   }
   * //   Error: ConnectionError: Connection timeout after 5000ms
   * //   Stack: Error: Connection timeout...
   * //     at Connection.connect...
   * //   Duration: 5234ms
   * ```
   */
  format(entry: LogEntry): string {
    const timestamp = this.formatTimestamp(entry.timestamp);
    const level = LogLevel[entry.level].padEnd(5);
    const color = this.colors[entry.level] || this.reset;

    let output = `${color}[${timestamp}] ${level} ${this.config.service}: ${entry.message}${this.reset}`;

    // Add context if present
    if (entry.context && Object.keys(entry.context).length > 0) {
      output += `\n${color}  Context: ${JSON.stringify(entry.context, null, 2)}${this.reset}`;
    }

    // Add error if present
    if (entry.error) {
      output += `\n${color}  Error: ${entry.error.name}: ${entry.error.message}`;
      if (entry.error.stack && this.config.environment === 'development') {
        output += `\n${color}  Stack: ${entry.error.stack}${this.reset}`;
      }
    }

    // Add duration if present
    if (entry.duration) {
      output += `\n${color}  Duration: ${entry.duration}ms${this.reset}`;
    }

    return output;
  }

  /**
   * Formats a timestamp according to the configured timestamp format.
   *
   * @private
   * @param {Date} timestamp - The timestamp to format
   * @returns {string} Formatted timestamp string
   *
   * @example
   * ```typescript
   * // ISO format: "2024-01-15T10:30:00.000Z"
   * // UTC format: "Mon, 15 Jan 2024 10:30:00 GMT"
   * // LOCAL format: "1/15/2024, 10:30:00 AM"
   * ```
   */
  private formatTimestamp(timestamp: Date): string {
    switch (this.config.timestampFormat) {
      case 'ISO':
        return timestamp.toISOString();
      case 'UTC':
        return timestamp.toUTCString();
      case 'LOCAL':
        return timestamp.toLocaleString();
      default:
        return timestamp.toISOString();
    }
  }
}
import { LogEntry, LogLevel, LoggerConfig } from '@/types';
import { JsonFormat, PrettyFormat } from './formats';

/**
 * Main logger class for the CertusAdiValt system with structured logging capabilities.
 *
 * Provides a comprehensive logging solution with multiple log levels, formatting options,
 * sensitive data redaction, performance timing, and child logger support. Supports both
 * JSON and pretty-printed formats for different environments.
 *
 * @class ValtLogger
 *
 * @example
 * ```typescript
 * // Create logger instance
 * const logger = new ValtLogger({
 *   level: LogLevel.INFO,
 *   service: 'user-service',
 *   environment: 'production',
 *   version: '1.0.0',
 *   redactFields: ['password', 'token'],
 *   prettyPrint: false
 * });
 *
 * // Basic logging
 * logger.info('User logged in', { userId: '123', method: 'oauth' });
 * logger.error('Database connection failed', { host: 'db.example.com' }, error);
 *
 * // Performance timing
 * const result = logger.time('database-query', () => {
 *   return database.query('SELECT * FROM users');
 * });
 *
 * // Child logger with shared context
 * const requestLogger = logger.child({ requestId: 'req_123', userId: 'user_456' });
 * requestLogger.info('Processing request');
 * ```
 */
export class ValtLogger {
  private config: Required<LoggerConfig>;
  private jsonFormat: JsonFormat;
  private prettyFormat: PrettyFormat;

  /**
   * Creates a new ValtLogger instance with the specified configuration.
   *
   * @param {LoggerConfig} config - Logger configuration options
   *
   * @example
   * ```typescript
   * // Production configuration
   * const prodLogger = new ValtLogger({
   *   level: LogLevel.INFO,
   *   service: 'api-gateway',
   *   environment: 'production',
   *   version: '2.1.0',
   *   redactFields: ['password', 'authorization', 'apiKey'],
   *   prettyPrint: false
   * });
   *
   * // Development configuration
   * const devLogger = new ValtLogger({
   *   level: LogLevel.DEBUG,
   *   service: 'api-gateway',
   *   environment: 'development',
   *   prettyPrint: true
   * });
   * ```
   */
  constructor(config: LoggerConfig) {
    this.config = {
      level: config.level,
      service: config.service,
      environment: config.environment,
      version: config.version || '1.0.0',
      redactFields: config.redactFields || [],
      prettyPrint: config.prettyPrint || false,
      timestampFormat: config.timestampFormat || 'ISO',
    };

    this.jsonFormat = new JsonFormat(this.config);
    this.prettyFormat = new PrettyFormat(this.config);
  }

  /**
   * Checks if a log level should be logged based on configured minimum level.
   *
   * @private
   * @param {LogLevel} level - The log level to check
   * @returns {boolean} True if the level should be logged
   */
  private shouldLog(level: LogLevel): boolean {
    return level <= this.config.level;
  }

  /**
   * Creates a structured log entry with proper formatting and redaction.
   *
   * @private
   * @param {LogLevel} level - The log level
   * @param {string} message - The log message
   * @param {Record<string, unknown>} [context] - Optional context data
   * @param {Error} [error] - Optional error object
   * @returns {LogEntry} Structured log entry
   */
  private createLogEntry(
    level: LogLevel,
    message: string,
    context?: Record<string, unknown>,
    error?: Error
  ): LogEntry {
    const baseContext: any = {
      timestamp: new Date(),
      ...context,
    };

    const logEntry: LogEntry = {
      ...baseContext,
      level,
      message,
      service: this.config.service,
      environment: this.config.environment,
      version: this.config.version,
      context: this.redactSensitiveData(context || {}),
    };

    if (error) {
      logEntry.error = {
        name: error.name,
        message: error.message,
        stack: this.config.environment === 'development' ? error.stack : undefined,
        ...((error as any).code && { code: (error as any).code }),
        ...((error as any).statusCode && { statusCode: (error as any).statusCode }),
      };
    }

    return logEntry;
  }

  /**
   * Redacts sensitive data from context objects based on configuration.
   *
   * @private
   * @param {Record<string, unknown>} data - The data to redact
   * @returns {Record<string, unknown>} Redacted data
   */
  private redactSensitiveData(data: Record<string, unknown>): Record<string, unknown> {
    if (!this.config.redactFields.length) return data;

    const redacted = { ...data };
    for (const field of this.config.redactFields) {
      if (field in redacted) {
        redacted[field] = '[REDACTED]';
      }
    }
    return redacted;
  }

  /**
   * Writes a log entry to the appropriate output stream with formatting.
   *
   * @private
   * @param {LogEntry} entry - The log entry to write
   */
  private writeLog(entry: LogEntry): void {
    const formattedLog = this.config.prettyPrint
      ? this.prettyFormat.format(entry)
      : this.jsonFormat.format(entry);

    const consoleMethod = this.getConsoleMethod(entry.level);
    consoleMethod(formattedLog);
  }

  /**
   * Gets the appropriate console method for a log level.
   *
   * @private
   * @param {LogLevel} level - The log level
   * @returns {(...args: any[]) => void} Console method function
   */
  private getConsoleMethod(level: LogLevel): (...args: any[]) => void {
    switch (level) {
      case LogLevel.ERROR:
        return console.error;
      case LogLevel.WARN:
        return console.warn;
      case LogLevel.INFO:
        return console.info;
      case LogLevel.DEBUG:
      case LogLevel.TRACE:
        return console.debug;
      default:
        return console.log;
    }
  }

  // Public API methods

  /**
   * Logs an error message with optional context and error object.
   *
   * @param {string} message - The error message
   * @param {Record<string, unknown>} [context] - Optional context data
   * @param {Error} [error] - Optional error object
   *
   * @example
   * ```typescript
   * try {
   *   await someOperation();
   * } catch (error) {
   *   logger.error('Operation failed', { operation: 'user-create' }, error);
   * }
   *
   * logger.error('Invalid configuration', { configKey: 'database.url' });
   * ```
   */
  error(message: string, context?: Record<string, unknown>, error?: Error): void {
    if (!this.shouldLog(LogLevel.ERROR)) return;
    const entry = this.createLogEntry(LogLevel.ERROR, message, context, error);
    this.writeLog(entry);
  }

  /**
   * Logs a warning message with optional context and error object.
   *
   * @param {string} message - The warning message
   * @param {Record<string, unknown>} [context] - Optional context data
   * @param {Error} [error] - Optional error object
   *
   * @example
   * ```typescript
   * logger.warn('Deprecated API called', { endpoint: '/v1/users', alternative: '/v2/users' });
   * logger.warn('High memory usage', { usage: '85%', threshold: '80%' });
   * ```
   */
  warn(message: string, context?: Record<string, unknown>, error?: Error): void {
    if (!this.shouldLog(LogLevel.WARN)) return;
    const entry = this.createLogEntry(LogLevel.WARN, message, context, error);
    this.writeLog(entry);
  }

  /**
   * Logs an informational message with optional context.
   *
   * @param {string} message - The info message
   * @param {Record<string, unknown>} [context] - Optional context data
   *
   * @example
   * ```typescript
   * logger.info('User registered', { userId: '123', method: 'email' });
   * logger.info('Server started', { port: 3000, environment: 'production' });
   * ```
   */
  info(message: string, context?: Record<string, unknown>): void {
    if (!this.shouldLog(LogLevel.INFO)) return;
    const entry = this.createLogEntry(LogLevel.INFO, message, context);
    this.writeLog(entry);
  }

  /**
   * Logs a debug message with optional context.
   *
   * @param {string} message - The debug message
   * @param {Record<string, unknown>} [context] - Optional context data
   *
   * @example
   * ```typescript
   * logger.debug('Database query executed', { query: 'SELECT * FROM users', duration: 45 });
   * logger.debug('Cache hit', { key: 'user:123', ttl: 300 });
   * ```
   */
  debug(message: string, context?: Record<string, unknown>): void {
    if (!this.shouldLog(LogLevel.DEBUG)) return;
    const entry = this.createLogEntry(LogLevel.DEBUG, message, context);
    this.writeLog(entry);
  }

  /**
   * Logs a trace message with optional context.
   *
   * @param {string} message - The trace message
   * @param {Record<string, unknown>} [context] - Optional context data
   *
   * @example
   * ```typescript
   * logger.trace('Function called', { args: ['param1', 'param2'], caller: 'userService' });
   * logger.trace('State updated', { previous: 'pending', current: 'completed' });
   * ```
   */
  trace(message: string, context?: Record<string, unknown>): void {
    if (!this.shouldLog(LogLevel.TRACE)) return;
    const entry = this.createLogEntry(LogLevel.TRACE, message, context);
    this.writeLog(entry);
  }

  /**
   * Times the execution of a function and logs the duration.
   *
   * @template T - The return type of the function
   * @param {string} operation - The operation name for logging
   * @param {() => T} fn - The function to time
   * @param {Record<string, unknown>} [context] - Optional context data
   * @returns {T} The result of the function
   *
   * @example
   * ```typescript
   * // Sync function
   * const result = logger.time('process-data', () => {
   *   return processLargeDataset(data);
   * }, { records: data.length });
   *
   * // Async function
   * const user = await logger.time('fetch-user', async () => {
   *   return await userRepository.findById(userId);
   * }, { userId });
   *
   * // With error handling
   * try {
   *   const result = logger.time('risky-operation', riskyFunction, { param: value });
   * } catch (error) {
   *   // Duration is logged even if operation fails
   * }
   * ```
   */
  time<T>(operation: string, fn: () => T, context?: Record<string, unknown>): T {
    const start = Date.now();
    try {
      const result = fn();
      if (result instanceof Promise) {
        return result.then((res) => {
          this.logDuration(operation, Date.now() - start, context);
          return res;
        }) as T;
      }
      this.logDuration(operation, Date.now() - start, context);
      return result;
    } catch (error) {
      this.logDuration(operation, Date.now() - start, { ...context, error });
      throw error;
    }
  }

  /**
   * Logs the duration of an operation.
   *
   * @private
   * @param {string} operation - The operation name
   * @param {number} duration - The duration in milliseconds
   * @param {Record<string, unknown>} [context] - Optional context data
   */
  private logDuration(
    operation: string,
    duration: number,
    context?: Record<string, unknown>
  ): void {
    if (!this.shouldLog(LogLevel.INFO)) return;

    const level = duration > 1000 ? LogLevel.WARN : LogLevel.INFO;
    const message = `${operation} completed in ${duration}ms`;

    const entry = this.createLogEntry(level, message, {
      ...context,
      operation,
      duration,
      durationUnit: 'ms',
    });

    this.writeLog(entry);
  }

  /**
   * Creates a child logger with inherited context.
   *
   * @param {Record<string, unknown>} context - Context to include in all child logs
   * @returns {ValtLogger} Child logger instance
   *
   * @example
   * ```typescript
   * // Create child logger for request context
   * const requestLogger = logger.child({
   *   requestId: 'req_123',
   *   userId: 'user_456',
   *   sessionId: 'sess_789'
   * });
   *
   * requestLogger.info('Processing request'); // Includes request context
   * requestLogger.debug('Database query', { table: 'users' }); // Merges contexts
   *
   * // Create child logger for module context
   * const authLogger = logger.child({ module: 'authentication' });
   * authLogger.info('User authenticated', { method: 'jwt' });
   * ```
   */
  child(context: Record<string, unknown>): ValtLogger {
    const childConfig = {
      ...this.config,
      service: this.config.service,
    };

    const childLogger = new ValtLogger(childConfig);

    // Override createLogEntry to include parent context
    const originalCreateLogEntry = childLogger.createLogEntry.bind(childLogger);
    childLogger.createLogEntry = (
      level: LogLevel,
      message: string,
      childContext?: Record<string, unknown>,
      error?: Error
    ) => {
      const mergedContext = { ...context, ...childContext };
      return originalCreateLogEntry(level, message, mergedContext, error);
    };

    return childLogger;
  }
}
import { Request, Response, NextFunction } from 'express';
import { randomUUID } from 'crypto';

/**
 * Express middleware for generating and managing correlation IDs across distributed systems.
 *
 * Provides request tracing capabilities by generating unique correlation IDs (request IDs)
 * that can be used to track requests as they flow through multiple services. Supports both
 * generating new IDs and propagating existing IDs from incoming headers.
 *
 * @class CorrelationMiddleware
 *
 * @example
 * ```typescript
 * // Basic usage
 * const correlationMiddleware = new CorrelationMiddleware();
 * app.use(correlationMiddleware.generateRequestId());
 *
 * // With existing request ID from headers
 * // If client sends 'x-request-id' header, it will be reused
 * // Otherwise, a new UUID will be generated
 *
 * // The middleware automatically:
 * // - Reads existing 'x-request-id' header from incoming request
 * // - Generates new UUID if no header exists
 * // - Sets the request ID in both request and response headers
 * // - Makes the request ID available throughout the request lifecycle
 * ```
 *
 * @example
 * ```typescript
 * // Accessing request ID in route handlers
 * app.get('/api/users', (req: Request, res: Response) => {
 *   const requestId = req.headers['x-request-id'];
 *   logger.info('Processing user request', { requestId });
 *   // Logs: { message: "Processing user request", requestId: "abc-123-xyz" }
 * });
 *
 * // Response headers will include:
 * // x-request-id: abc-123-xyz
 * ```
 */
export class CorrelationMiddleware {
  /**
   * Generates Express middleware for request ID correlation.
   *
   * Creates middleware that ensures every request has a unique correlation ID,
   * either by reusing an existing 'x-request-id' header from the client or
   * generating a new UUIDv4. The ID is propagated through both request and
   * response headers for distributed tracing.
   *
   * @returns {function} Express middleware function
   *
   * @example
   * ```typescript
   * // Application setup
   * const app = express();
   * const correlation = new CorrelationMiddleware();
   *
   * // Apply middleware globally
   * app.use(correlation.generateRequestId());
   *
   * // Or apply to specific routes
   * app.use('/api/*', correlation.generateRequestId());
   *
   * // The middleware will:
   * // 1. Check for existing 'x-request-id' in request headers
   * // 2. Use existing ID if present, generate new UUID if not
   * // 3. Set the ID in request headers for downstream use
   * // 4. Set the ID in response headers for client propagation
   * ```
   */
  generateRequestId() {
    return (req: Request, res: Response, next: NextFunction) => {
      const existingRequestId = req.headers['x-request-id'];
      const requestId = existingRequestId || randomUUID();

      // Set request ID in request and response
      req.headers['x-request-id'] = requestId;
      res.setHeader('x-request-id', requestId);

      next();
    };
  }
}
import { Request, Response, NextFunction } from 'express';
import { ValtLogger } from '../logger';
import { isErrorResponse, ResponseFormatter } from '@/responses';
import { CertusAdiValtError } from '@/certus';
import { HttpStatus } from '@/constants';

/**
 * Express middleware for comprehensive error handling and 404 route management.
 *
 * Provides centralized error handling for Express applications with structured logging,
 * consistent error response formatting, and proper 404 handling. Integrates seamlessly
 * with the ValtLogger for error tracking and CorrelationMiddleware for request tracing.
 *
 * @class ErrorMiddleware
 *
 * @example
 * ```typescript
 * // Application setup with error middleware
 * const logger = new ValtLogger({ /* config *\/ });
 * const errorMiddleware = new ErrorMiddleware(logger);
 *
 * const app = express();
 *
 * // Apply middleware in correct order
 * app.use(express.json());
 * app.use(correlationMiddleware.generateRequestId());
 *
 * // Your routes here
 * app.use('/api', apiRoutes);
 *
 * // 404 handler for unmatched routes (should be after all routes)
 * app.use(errorMiddleware.notFound());
 *
 * // Global error handler (should be last middleware)
 * app.use(errorMiddleware.handle());
 * ```
 */
export class ErrorMiddleware {
  private logger: ValtLogger;

  /**
   * Creates a new ErrorMiddleware instance with the specified logger.
   *
   * @param {ValtLogger} logger - Logger instance for structured error logging
   *
   * @example
   * ```typescript
   * // Production setup
   * const productionLogger = new ValtLogger({
   *   level: LogLevel.ERROR,
   *   service: 'api-server',
   *   environment: 'production'
   * });
   *
   * const errorMiddleware = new ErrorMiddleware(productionLogger);
   *
   * // Development setup
   * const devLogger = new ValtLogger({
   *   level: LogLevel.DEBUG,
   *   service: 'api-server',
   *   environment: 'development',
   *   prettyPrint: true
   * });
   *
   * const devErrorMiddleware = new ErrorMiddleware(devLogger);
   * ```
   */
  constructor(logger: ValtLogger) {
    this.logger = logger;
  }

  /**
   * Global error handler middleware for Express applications.
   *
   * Catches all errors thrown in the application, logs them with comprehensive context,
   * and returns formatted error responses. Integrates with request ID correlation for
   * distributed tracing and provides environment-appropriate error details.
   *
   * @returns {function} Express error handling middleware
   *
   * @example
   * ```typescript
   * // Error handling in action:
   *
   * // 1. Database error
   * app.get('/users/:id', async (req, res) => {
   *   const user = await db.users.find(req.params.id); // Throws if not found
   *   res.json(user);
   * });
   *
   * // If user not found, error is caught by handle() middleware:
   * // - Logs: { message: "Request processing error", method: "GET", path: "/users/123", ... }
   * // - Returns: { error: { message: "User not found", code: "DB_NOT_FOUND", statusCode: 404 } }
   *
   * // 2. Validation error
   * app.post('/users', (req, res) => {
   *   if (!req.body.email) {
   *     throw new CertusAdiValtError('Email is required', 'VALIDATION_ERROR', 400);
   *   }
   * });
   * ```
   */
  handle() {
    return (error: Error, req: Request, res: Response, next: NextFunction) => {
      const requestId = req.headers['x-request-id'] as string;

      // Log the error
      this.logger.error(
        'Request processing error',
        {
          method: req.method,
          path: req.path,
          requestId,
          ip: req.ip,
          userAgent: req.get('User-Agent'),
        },
        error
      );

      // Format and send error response
      const response = ResponseFormatter.formatError(error, {
        requestId,
        includeDetails: process.env.NODE_ENV === 'development',
      });

      if (isErrorResponse(response)) {
        res.status(response.error.statusCode).json(response);
      } else {
        res.status(HttpStatus.INTERNAL_SERVER_ERROR).json(response);
      }
    };
  }

  /**
   * 404 Not Found handler middleware for unmatched routes.
   *
   * Catches all requests to undefined routes and returns consistent 404 error responses.
   * Creates structured CertusAdiValtError instances with route context for proper
   * error formatting and logging.
   *
   * @returns {function} Express middleware for 404 handling
   *
   * @example
   * ```typescript
   * // 404 handling examples:
   *
   * // Request to undefined route: GET /api/nonexistent
   * // Returns: {
   * //   error: {
   * //     message: "Route GET /api/nonexistent not found",
   * //     code: "CLI_NOT_FOUND",
   * //     statusCode: 404,
   * //     details: { method: "GET", path: "/api/nonexistent" }
   * //   }
   * // }
   *
   * // Proper middleware order:
   * app.use('/api', apiRoutes);        // Your API routes
   * app.use('/docs', docsRoutes);      // Documentation routes
   * app.use(errorMiddleware.notFound()); // 404 for everything else
   * app.use(errorMiddleware.handle());   // Error handler last
   * ```
   */
  notFound() {
    return (req: Request, res: Response, next: NextFunction) => {
      const requestId = req.headers['x-request-id'] as string;

      const error = new CertusAdiValtError(
        `Route ${req.method} ${req.path} not found`,
        'CLI_NOT_FOUND',
        404,
        { method: req.method, path: req.path }
      );

      const response = ResponseFormatter.formatError(error, { requestId });
      res.status(404).json(response);
    };
  }
}
import { Request, Response, NextFunction } from 'express';
import { ValtLogger } from '../logger';

/**
 * Express middleware for comprehensive request logging with performance monitoring.
 *
 * Provides detailed logging of incoming HTTP requests and responses, including
 * timing information, status codes, and contextual data. Integrates with the
 * ValtLogger for structured logging and CorrelationMiddleware for request tracing.
 *
 * @class LoggingMiddleware
 *
 * @example
 * ```typescript
 * // Application setup with logging middleware
 * const logger = new ValtLogger({ /* config *\/ });
 * const loggingMiddleware = new LoggingMiddleware(logger);
 *
 * const app = express();
 *
 * // Apply middleware in correct order
 * app.use(loggingMiddleware.requestLogger()); // Should be after correlation middleware
 * app.use(express.json());
 * // ... other middleware and routes
 *
 * // Example log output:
 * // Request start: { message: "Incoming request", method: "GET", path: "/api/users", ... }
 * // Request completion: { message: "Request completed: 200 OK in 45ms", statusCode: 200, duration: 45, ... }
 * ```
 */
export class LoggingMiddleware {
  private logger: ValtLogger;

  /**
   * Creates a new LoggingMiddleware instance with the specified logger.
   *
   * @param {ValtLogger} logger - Logger instance for structured request logging
   *
   * @example
   * ```typescript
   * // Production configuration
   * const prodLogger = new ValtLogger({
   *   level: LogLevel.INFO,
   *   service: 'api-gateway',
   *   environment: 'production',
   *   redactFields: ['password', 'authorization']
   * });
   *
   * const prodLogging = new LoggingMiddleware(prodLogger);
   *
   * // Development configuration
   * const devLogger = new ValtLogger({
   *   level: LogLevel.DEBUG,
   *   service: 'api-gateway',
   *   environment: 'development',
   *   prettyPrint: true
   * });
   *
   * const devLogging = new LoggingMiddleware(devLogger);
   * ```
   */
  constructor(logger: ValtLogger) {
    this.logger = logger;
  }

  /**
   * Request logging middleware for Express applications.
   *
   * Logs incoming requests with comprehensive context and tracks response completion
   * with timing information. Automatically categorizes logs as warnings for error
   * status codes (400+). Captures request details, response metrics, and performance
   * data for monitoring and debugging.
   *
   * @returns {function} Express middleware function
   *
   * @example
   * ```typescript
   * // Middleware application
   * app.use(loggingMiddleware.requestLogger());
   *
   * // Example log outputs:
   *
   * // Successful request (GET /api/users?page=1)
   * // Request: { message: "Incoming request", method: "GET", path: "/api/users", query: { page: "1" }, ... }
   * // Response: { message: "Request completed: 200 OK in 120ms", statusCode: 200, duration: 120, ... }
   *
   * // Error request (POST /api/login with invalid credentials)
   * // Request: { message: "Incoming request", method: "POST", path: "/api/login", ... }
   * // Response: { message: "Request completed: 401 Unauthorized in 45ms", statusCode: 401, duration: 45, ... }
   *
   * // Slow request (GET /api/reports)
   * // Response: { message: "Request completed: 200 OK in 2500ms", statusCode: 200, duration: 2500, ... }
   * ```
   */
  requestLogger() {
    return (req: Request, res: Response, next: NextFunction) => {
      const start = Date.now();
      const requestId = req.headers['x-request-id'] as string;

      // Log request start
      this.logger.info('Incoming request', {
        method: req.method,
        path: req.path,
        requestId,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        query: req.query,
        params: req.params,
      });

      // Capture response finish
      res.on('finish', () => {
        const duration = Date.now() - start;
        const context = {
          method: req.method,
          path: req.path,
          requestId,
          statusCode: res.statusCode,
          duration,
          contentLength: res.get('Content-Length'),
          userAgent: req.get('User-Agent'),
        };

        const level = res.statusCode >= 400 ? 'warn' : 'info';
        const message = `Request completed: ${res.statusCode} ${res.statusMessage} in ${duration}ms`;

        if (level === 'warn') {
          this.logger.warn(message, context);
        } else {
          this.logger.info(message, context);
        }
      });

      next();
    };
  }
}
import { ResponseFormatter } from '@/responses';
import { Request, Response, NextFunction } from 'express';

/**
 * Express middleware for standardizing success response formatting across the API.
 *
 * Provides consistent success response formatting by intercepting and transforming
 * JSON responses. Ensures all successful API responses follow a standardized structure
 * with proper metadata, request correlation, and optional success messages.
 *
 * @class ResponseMiddleware
 *
 * @example
 * ```typescript
 * // Application setup with response middleware
 * const responseMiddleware = new ResponseMiddleware();
 *
 * const app = express();
 *
 * // Apply middleware after routes but before error handlers
 * app.use(responseMiddleware.successHandler());
 *
 * // Example route responses:
 *
 * // GET /api/users returns array of users
 * // Original: [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]
 * // Formatted: {
 * //   success: true,
 * //   data: [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }],
 * //   timestamp: '2023-10-05T12:00:00.000Z',
 * //   requestId: 'req_123'
 * // }
 *
 * // POST /api/users returns created user with 201 status
 * // Formatted: {
 * //   success: true,
 * //   data: { id: 3, name: 'New User' },
 * //   message: 'Resource created successfully',
 * //   timestamp: '2023-10-05T12:00:00.000Z',
 * //   requestId: 'req_123'
 * // }
 * ```
 */
export class ResponseMiddleware {
  /**
   * Success response formatting middleware for Express applications.
   *
   * Intercepts all JSON responses and applies consistent formatting to successful
   * responses. Preserves existing formatted responses, adds request correlation IDs,
   * and provides appropriate success messages for common status codes like 201 Created.
   *
   * @returns {function} Express middleware function
   *
   * @example
   * ```typescript
   * // Route handlers work normally - formatting is automatic
   *
   * app.get('/api/users', (req: Request, res: Response) => {
   *   const users = userService.getAll();
   *   res.json(users); // Automatically formatted
   * });
   *
   * app.post('/api/users', (req: Request, res: Response) => {
   *   const newUser = userService.create(req.body);
   *   res.status(201).json(newUser); // Gets "Resource created successfully" message
   * });
   *
   * app.get('/api/users/:id', (req: Request, res: Response) => {
   *   const user = userService.getById(req.params.id);
   *   res.json(user); // Single object formatted consistently
   * });
   *
   * // Already formatted responses are preserved
   * app.get('/api/custom', (req: Request, res: Response) => {
   *   const customResponse = {
   *     success: true,
   *     data: { custom: 'data' },
   *     customField: 'preserved'
   *   };
   *   res.json(customResponse); // Left unchanged due to existing 'success' field
   * });
   * ```
   */
  successHandler() {
    return (req: Request, res: Response, next: NextFunction) => {
      // Store original json method
      const originalJson = res.json;

      // Override json method to format responses
      res.json = function (data: any) {
        const requestId = req.headers['x-request-id'] as string;

        // If it's already a formatted response, use it as is
        if (data && typeof data === 'object' && 'success' in data) {
          return originalJson.call(this, data);
        }

        // Format success response
        const formattedResponse = ResponseFormatter.formatSuccess(data, {
          requestId,
          message: res.statusCode === 201 ? 'Resource created successfully' : undefined,
        });

        return originalJson.call(this, formattedResponse);
      };

      next();
    };
  }
}
/**
 * Utility class for sensitive data redaction in logs and API responses.
 *
 * Provides comprehensive data sanitization capabilities to prevent accidental
 * exposure of sensitive information. Supports recursive object traversal,
 * customizable sensitive field patterns, and specialized header redaction
 * for HTTP requests and responses.
 *
 * @class DataRedactor
 *
 * @example
 * ```typescript
 * // Basic data redaction
 * const userData = {
 *   name: 'John Doe',
 *   email: 'john@example.com',
 *   password: 'secret123',
 *   token: 'jwt-token-here',
 *   profile: {
 *     phone: '+1234567890',
 *     ssn: '123-45-6789'
 *   }
 * };
 *
 * const redacted = DataRedactor.redact(userData);
 * // Result:
 * // {
 * //   name: 'John Doe',
 * //   email: '[REDACTED]',
 * //   password: '[REDACTED]',
 * //   token: '[REDACTED]',
 * //   profile: {
 * //     phone: '[REDACTED]',
 * //     ssn: '[REDACTED]'
 * //   }
 * // }
 *
 * // Header redaction
 * const headers = {
 *   'authorization': 'Bearer jwt-token',
 *   'content-type': 'application/json',
 *   'cookie': 'session=abc123',
 *   'x-api-key': 'secret-key'
 * };
 *
 * const safeHeaders = DataRedactor.redactHeaders(headers);
 * // Result:
 * // {
 * //   'authorization': '[REDACTED]',
 * //   'content-type': 'application/json',
 * //   'cookie': '[REDACTED]',
 * //   'x-api-key': '[REDACTED]'
 * // }
 * ```
 */
export class DataRedactor {
  /**
   * Default sensitive field patterns that will be automatically redacted.
   * Includes common authentication, personal, and financial data fields.
   */
  private static defaultSensitiveFields = [
    'password',
    'token',
    'secret',
    'authorization',
    'apiKey',
    'creditCard',
    'ssn',
    'phone',
    'email',
  ];

  /**
   * Recursively redacts sensitive data from objects, arrays, and nested structures.
   *
   * Traverses through all levels of data structure and replaces values of sensitive
   * fields with '[REDACTED]'. Supports partial field name matching (case-insensitive)
   * and custom field patterns in addition to default sensitive fields.
   *
   * @param {any} data - The data to redact (object, array, or primitive)
   * @param {string[]} [sensitiveFields=[]] - Additional custom sensitive field patterns
   * @returns {any} Redacted data with sensitive values replaced
   *
   * @example
   * ```typescript
   * // Redact with custom fields
   * const customFields = ['internalId', 'employeeCode'];
   * const redacted = DataRedactor.redact(data, customFields);
   *
   * // Array handling
   * const users = [
   *   { name: 'John', password: '123', email: 'john@test.com' },
   *   { name: 'Jane', password: '456', email: 'jane@test.com' }
   * ];
   *
   * const safeUsers = DataRedactor.redact(users);
   * // Result: [
   * //   { name: 'John', password: '[REDACTED]', email: '[REDACTED]' },
   * //   { name: 'Jane', password: '[REDACTED]', email: '[REDACTED]' }
   * // ]
   *
   * // Nested object handling
   * const complexData = {
   *   user: {
   *     credentials: {
   *       username: 'john',
   *       password: 'secret',
   *       apiToken: 'token123'
   *     },
   *     contact: {
   *       phone: '1234567890',
   *       email: 'john@example.com'
   *     }
   *   }
   * };
   *
   * const safeComplexData = DataRedactor.redact(complexData);
   * // All sensitive fields at all nesting levels are redacted
   * ```
   */
  static redact(data: any, sensitiveFields: string[] = []): any {
    const fields = [...this.defaultSensitiveFields, ...sensitiveFields];

    if (Array.isArray(data)) {
      return data.map((item) => this.redact(item, fields));
    }

    if (data && typeof data === 'object') {
      const redacted = { ...data };

      for (const key of Object.keys(redacted)) {
        const lowerKey = key.toLowerCase();

        // Check if this field should be redacted
        if (fields.some((field) => lowerKey.includes(field.toLowerCase()))) {
          redacted[key] = '[REDACTED]';
        } else if (typeof redacted[key] === 'object') {
          redacted[key] = this.redact(redacted[key], fields);
        }
      }

      return redacted;
    }

    return data;
  }

  /**
   * Redacts sensitive information from HTTP headers object.
   *
   * Specifically targets common authentication and session headers that may
   * contain tokens, API keys, or other sensitive authentication data.
   * Preserves non-sensitive headers while replacing sensitive ones with '[REDACTED]'.
   *
   * @param {Record<string, string | string[] | undefined>} headers - HTTP headers object
   * @returns {Record<string, string | string[]>} Headers with sensitive values redacted
   *
   * @example
   * ```typescript
   * // Express request header redaction for logging
   * app.use((req: Request, res: Response, next: NextFunction) => {
   *   const safeHeaders = DataRedactor.redactHeaders(req.headers);
   *   logger.info('Request received', { headers: safeHeaders });
   *   next();
   * });
   *
   * // Redacting fetch API headers
   * const response = await fetch(url, { headers });
   * const loggableHeaders = DataRedactor.redactHeaders(headers);
   * logger.debug('API request', { headers: loggableHeaders });
   *
   * // Header preservation example:
   * const headers = {
   *   'authorization': 'Bearer eyJhbGciOi...', // → '[REDACTED]'
   *   'content-type': 'application/json',      // → preserved
   *   'user-agent': 'Mozilla/5.0...',          // → preserved
   *   'x-api-key': 'sk_live_123456',           // → '[REDACTED]'
   *   'cookie': 'session=abc123'               // → '[REDACTED]'
   * };
   * ```
   */
  static redactHeaders(
    headers: Record<string, string | string[] | undefined>
  ): Record<string, string | string[]> {
    const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key', 'x-auth-token'];

    const redacted = { ...headers };

    for (const header of sensitiveHeaders) {
      if (header in redacted) {
        redacted[header] = '[REDACTED]';
      }
    }

    return redacted as Record<string, string | string[]>;
  }
}
